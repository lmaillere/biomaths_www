{"title":"Populations en interactions","markdown":{"yaml":{"title":"Populations en interactions"},"headingText":"Le modèle proie-prédateur de Lotka et Volterra","headingAttr":{"id":"sec-lv","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n\n\nNous considérons le modèle de dynamique de populations de @Lotka1925 et @Volterra1926 :\n\n$$\n\\left\\{\\begin{array}{l}\n\\dot x = rx - c xy,\\\\\n\\dot y = bxy - m y.\n\\end{array}\\right.\n$$ {#eq-lovo}\n\n### Dynamiques\n\nIl n'y a pas de difficulté particulière à la simulation par rapport au modèle de la tordeuse du bourgeon de l'épinette avec population d'oiseaux variables.\n\n```{python}\n#| code-fold: true\n## on nettoie l'espace de travail et on reload les modules\n%reset -f\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n \n## densités initiales des populations\nx0 = 1\ny0 = 2.5\netat0_LV = np.array([x0, y0])\n\n## tspan\nt_0 = 0             \nt_fin = 30.0        \npas_t = 0.01        \ntspan = np.arange(t_0, t_fin, pas_t)\n\n## paramètres du modèle\nr = 1.0\nc = 1.0\nb = 1.0\nm = 1.0\nparams_LV = np.array([r, c, b, m])\n\n## définition du modèle de Lotka Volterra\ndef model_LV(etat, t, params):\n    x, y = etat                       # recupere les variables d'etat\n    r, c, b, m = params               # recupere les parametres \n    etatdot = [r*x - c*x*y,           # dot x\n               b*x*y - m*y]           # dot y\n    return etatdot                    # renvoie la derivee\n\n## simulation proprement dite\nint_LV = odeint(model_LV, etat0_LV, tspan, args=(params_LV,), hmax=pas_t)\n```\n\nReprésentation graphique contre le temps :\n\n```{python}\n#| code-fold: true\n#| label: fig-lovo-temps\n#| fig-cap: dynamiques des proies et prédateurs contre le temps dans le modèle de Lotka et Volterra (@eq-lovo)\n\n## création d'une figure, et d'un système d'axe\nfig1, ax1 = plt.subplots(1, 1)  \n\nfig1.suptitle(\"Dynamiques Proies - Prédateurs modèle de Lotka Volterra\",\n             va='top', fontsize='14')\n\n## tracé de x et y contre le temps\nax1.plot(tspan, int_LV[:, 0], color = 'C0', label = \"proies $x$\")\nax1.plot(tspan, int_LV[:, 1], color = 'C1', label = \"prédateurs $y$\")\n\n## axes & co\nax1.set_xlabel('Temps', fontsize='12')\nax1.set_ylabel('Densités de populations', fontsize='12')\nax1.legend()\nax1.grid()\n```\n\n### Plan de phase\n\nIl est intéressant de représenter les trajectoires dans l'espace d'état $(x,y)$, en combinaison avec une analyse qualitative du plan de phase (isoclines nulles, équilibres), une représentation du champs de vecteurs et de quelques morceaux de trajectoires sur le plan.\n\nCommençons par calculer les isoclines nulles et les équilibres.\n\n```{python}\n#| code-fold: true\n## array annexes pour le calcul et la représentation des isoclines nulles\nxplot = np.arange(0, 3, .1)  \nyplot = np.arange(0, 3, .1)\n\n## isoclines nulles de xdot\nnull_x_x = np.zeros_like(yplot)        # x = 0 isocline nulle de xdot\nnull_x_y = np.ones_like(xplot)*(r/c)   # y = r/c isocline nulle de xdot\n\n## isoclines nulles de ydot\nnull_y_y = np.zeros_like(xplot)        # y = 0 isocline nulle de ydot\nnull_y_x = np.ones_like(yplot)*(m/b)   # x = m/b isocline nulle de ydot\n\n## équilibres\neq_extinct = [0, 0]\neq_coex = [r/c, m/b]\n```\n\nPuis on trace le plan de phase.\n\n```{python}\n#| code-fold: true\n#| label: fig-lovo-plane\n#| fig-cap: plan de phase du modèle proies-prédateurs de Lotka Volterra (@eq-lovo)\n\n## création d'une figure, et d'un système d'axe\nfig2, ax2 = plt.subplots(1, 1)  \n\n## titre de la figure\nfig2.suptitle(\"Dynamiques Proies - Prédateurs modèle de Lotka Volterra\", \n            va='top', fontsize='14')\n\n## isoclines nulles \nax2.plot(null_x_x, yplot, color = 'C2')\nax2.plot(xplot, null_x_y, color = 'C2', label = \"isoclines nulles de $\\dot x$\")\nax2.plot(xplot, null_y_y, color = 'C1')\nax2.plot(null_y_x, yplot, color = 'C1', label = \"isoclines nulles de $\\dot y$\")\n\n## équilibres\nax2.plot(eq_extinct[0], eq_extinct[1], marker ='.', color = 'C3', markersize = 16)\nax2.plot(eq_coex[0], eq_coex[1], marker ='.', \n        color = 'C0', markersize = 16)\n## trajectoires\nax2.plot(int_LV[:, 0], int_LV[:, 1], color = 'C0', label = \"trajectoire\")\n\n## enluminures\nax2.set_xlabel('Proies $x$', fontsize='12')\nax2.set_ylabel('Prédateurs $y$', fontsize='12')\nax2.legend(fontsize='10', loc = \"upper right\")\n\n## modification éventuelle des bornes des axes\nax2.set_ylim(bottom=-.1, top=None)\nax2.set_xlim(left=-.1, right=None);\n```\n\nComplètons ce plan de phase avec l'orientation du champs de vecteurs (fonction `quiver`) et des échantillons de trajectoires (fonction `streamplot`). Ces représentations reposent sur la définition d'une grille de coordonnées sur le plan, via une `meshgrid`.\n\n```{python}\n## définition de l'échantillonnage selon $x$ et $y$\nx_grid = np.linspace(0.1, 3.0, 10)   # au passage on change un peu de np.arange()\ny_grid = np.linspace(0.1, 3.0, 10)\n\n## grille X,Y selon x_grid et y_grid\nX, Y = np.meshgrid(x_grid, y_grid)\n```\n\nSur cette grille, on calcule les dérivées $\\dot x$ et $\\dot y$ :\n\n```{python}\ndx, dy = model_LV([X, Y], 0, params_LV)\n```\n\nEt on peut compléter le plan de phase :\n\n```{python}\n#| label: fig-lovo-plane-complet\n#| fig-cap: plan de phase du modèle proies-prédateurs de Lotka Volterra \n\n## tracé du champs de vecteur\nax2.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', width = .002)\n\n## tracé des échantillons de trajectoires\nax2.streamplot(X, Y, dx, dy, density = 0.4, maxlength = 0.25, color = \"purple\")\n\ndisplay(fig2)\n```\n\n:::{.callout-important}\nAttention à l'option `angles ='xy'` de `quiver`: les flèches sont ainsi tracées avec orientation en unité naturelle de l'écran et pas en unité naturelle de la figure qui est le comportement par défaut de la méthode (qui n'est pas naturel).\n:::\n\n### Intégrale première\n\nFinalement on peut représenter l'intégrale première de ce système. Commençons par la définir selon les calculs faits en cours :\n\n$$\nH(x,y) = -r\\log(y)+ c y - m \\log(x) + b x.\n$$\n\n```{python}\ndef int_premiere(etat, params):\n    x, y = etat                       \n    r, c, b, m = params               \n    H_xy = -r*np.log(y) + c*y - m*np.log(x) + b*x  \n    return H_xy\n```\n\nEffectuons une représentation graphique en 3D dans l'espace $(x, y, H)$, ce qui fournit un visuel intéressant.\n\nPour celà nous avons besoin d'une `meshgrid` plus précise que celle définie plus haut.\n\n```{python}\n#| code-fold: true\nx_grid = np.linspace(0.15, 3.0, 30)   \ny_grid = np.linspace(0.15, 3.0, 30)\nX, Y = np.meshgrid(x_grid, y_grid)\n```\n\n```{python}\n#| label: fig-int-prem\n#| fig-cap: intégrale première du modèle proies prédateurs de Lotka Volterra (@eq-lovo)\n\nfig3, ax3 = plt.subplots(1, 1, subplot_kw={\"projection\": \"3d\"})  \n\n## colormaps\nfrom matplotlib import cm\n\n## intégrale première sur la grille X, Y\nax3.plot_surface(X, Y, int_premiere([X, Y], params_LV),\n             cmap=cm.viridis, antialiased=True, alpha =.7)\n\n## réglage de l'angle de vision en fonction de l'élévation et de l'azimut\nax3.view_init(elev=10, azim= 30)\n\n## labellisation des axes\nax3.set_xlabel('Proies $x$', fontsize='12')\nax3.set_ylabel('Prédateurs $y$', fontsize='12')\nax3.set_zlabel('Intégrale première', fontsize='12')\n\nax3.set_yticklabels([])\nax3.set_xticklabels([])\nax3.set_zticklabels([])\nfig3.suptitle(\"Intégrale première\\n modèle de Lotka Volterra\", \n            va='top', fontsize='14');\n```\n\nOn rajoute la trajectoire et la valeur $H(x,y) = H(x_0, y_0)$ :\n\n```{python}\n#| label: fig-int-prem-full\n#| fig-cap: intégrale première du modèle proies prédateurs de Lotka Volterra (@eq-lovo)\n\n## H(x,y) = H(x0,y0)\nax3.plot_surface(X, Y, \n                np.ones_like(X)*int_premiere([x0, y0], params_LV), \n                antialiased=True, alpha =.3)\n\n## trajectoire\nax3.plot(int_LV[:,0], int_LV[:,1], \n         int_premiere([int_LV[:,0], int_LV[:,1]], params_LV), \n         color = \"red\", linewidth = 3)\n\ndisplay(fig3)\n```\n\n\n## Le modèle de Rosenzweig MacArthur {#sec-rma}\n\nNous considérons le modèle de dynamique de populations attribué à Rosenzweig et MacArthur (voir @Rosenzweig1963, @Turchin2003, @Smith2008).\n\n$$\n\\left\\{\\begin{array}{l}\n\\dot x = \\displaystyle rx\\left(1-\\frac{x}{K}\\right) - c \\frac{x}{h+x} y\\\\[.3cm]\n\\dot y = b\\displaystyle \\frac{x}{h+x} y - m y\n\\end{array}\\right.\n$$ {#eq-rma}\n\n### Dynamiques et plan de phase\n\nIl n'y a pas de difficulté particulière à la simulation par rapport au modèle de Lotka Volterra.\n\n```{python}\n#| code-fold: true\n%reset -f\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\n## densités initiales des populations\nx0 = 1\ny0 = 2.5\netat0_RMA = np.array([x0, y0])\n\n## tspan \nt_0 = 0             \nt_fin = 80.0        \npas_t = 0.01         \ntspan = np.arange(t_0, t_fin, pas_t)\n\n## paramètres (il y a un cycle limite attractif pour ces valeurs)\nr = 1.0\nK = 10\nc = 1.0\nh = 2.0\nb = 2.0\nm = 1.0\nparams_RMA = np.array([r, K, c, h, b, m])\n\n## modèle \ndef model_RMA(etat, t, params):\n    x, y = etat                               \n    r, K, c, h, b, m = params               \n    etatdot = [r*x*(1-x/K) - c*x/(h+x)*y,   \n               b*x/(h+x)*y - m*y]       \n    return etatdot                     \n\n## simulation \nint_RMA = odeint(model_RMA, etat0_RMA, tspan, args=(params_RMA,), hmax=pas_t)\n```\n\nReprésentation graphique des trajectoires contre le temps :\n\n```{python}\n#| code-fold: true\n#| label: fig-rma-temps\n#| fig-cap: simulation des trajectoires du modèle de Rosenzweig et MacArthur (@eq-rma)\n\nfig1, ax1 = plt.subplots(1, 1)  \nfig1.suptitle(\"Dynamiques du modèle de Rosenzweig - MacArthur\", \n            va='top', fontsize='14')\n\n## tracé de x et y contre le temps\nax1.plot(tspan, int_RMA[:, 0], color = 'C0', label = \"proies $x$\")\nax1.plot(tspan, int_RMA[:, 1], color = 'C1', label = \"prédateurs $y$\")\n\n## enluminures\nax1.set_xlabel('temps', fontsize='12')\nax1.set_ylabel('densités de populations', fontsize='12')\nax1.legend(fontsize='10')\nax1.grid()\n```\n\nReprésentation graphique dans le plan de phase :\n\n```{python}\n#| code-fold: true\n#| label: fig-rma-plane\n#| fig-cap: plan de phase du modèle de Rosenzweig et MacArthur (@eq-rma)\n\nfig2, ax2 = plt.subplots(1, 1)  \nfig2.suptitle(\"Plan de phase du modèle de Rosenzweig - MacArthur\", \n                va='top', fontsize='14')\n\n## calcul des isoclines nulles\nxplot = np.arange(0, K+.1, .1)  \nyplot = np.arange(0, K+.1, .1)\n\nnull_x_x = np.zeros_like(yplot)        \nnull_x_y = r/c*(h+xplot)*(1-xplot/K)   \n\nnull_y_y = np.zeros_like(xplot)        \nnull_y_x = np.ones_like(yplot)*m*h/(b-m)\n\n## équilibres\neq_extinct = [0, 0]\neq_coex = [m*h/(b-m), r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K)]\neq_prey = [K, 0]\n\n## tracé des isoclines nulles, des équilibres, et de la trajectoire simulée\nax2.plot(null_x_x, yplot, color = 'C2')\nax2.plot(xplot, null_x_y, color = 'C2', label = \"isoclines nulles de $\\dot x$\")\nax2.plot(xplot, null_y_y, color = 'C1')\nax2.plot(null_y_x, yplot, color = 'C1', label = \"isoclines nulles de $\\dot y$\")\n\n## équilibres\nax2.plot(eq_extinct[0], eq_extinct[1], marker ='.', color = 'C3', markersize = 16)\nax2.plot(eq_coex[0], eq_coex[1], marker ='.', color = 'C3', markersize = 16)\nax2.plot(eq_prey[0], eq_prey[1], marker ='.', color = 'C3', markersize = 16)\n\n## trajectoires\nax2.plot(int_RMA[:, 0], int_RMA[:, 1], color = 'C0', label = \"trajectoire\")\n\n## enluminures\nax2.set_xlabel('Proies $x$', fontsize='12')\nax2.set_ylabel('Prédateurs $y$', fontsize='12')\nax2.legend(fontsize='10', loc = \"upper right\")\nax2.set_ylim(bottom=-2, top=None)\nax2.set_xlim(left=-2, right=None)\n\n## représentation du champs de vecteurs\nx_grid = np.linspace(0.1, K, 10)   \ny_grid = np.linspace(0.1, K, 10)\nX, Y = np.meshgrid(x_grid, y_grid)\n\n## dérivées dot_x et dot_y sur la grille\ndx, dy = model_RMA([X, Y], 0, params_RMA)\n\nax2.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', width = .002);\n```\n\n### Diagramme de bifurcations \n\nNous allons représenter les asymptotiques de la population de prédateurs $y^*$ en fonction de $K$. Il y a 3 situations asymptotiques distinctes pour le modèle de Rosenzweig MacArthur :\n\n- si : $0<K<\\displaystyle\\frac{mh}{b-m}$ : les prédateurs s'éteignent et les proies convergent vers $K$, l'équilibre d'extinction des deux populations est instable.\n\n- si : $\\displaystyle\\frac{mh}{b-m} <K< h+\\frac{2mh}{b-m}$ : proies et prédateurs co-existent à un équilibre globalement asymptotiquement stable, l'équilibre d'extinction des prédateurs est instable, l'équilibre d'extinction des deux populations est instable.\n\n- si : $h+\\displaystyle\\frac{2mh}{b-m}<K$ proies et prédateurs co-existent le long d'un cycle limite globalement asymptotiquement stable, l'équilibre d'extinction des prédateurs est instable, l'équilibre d'extinction des deux populations est instable.\n\n\nDans un premier temps nous allons calculer et représenter les différents équilibres et leur stabilité dans le plan $(K, y)$, puis nous calculerons et rajouterons une représentation du cycle limite.\n\nCommençons par les équilibres :\n```{python}\n#| code-fold: true\npas_K = .1\n\n## situation 1. \nKplot1 = np.arange(pas_K, m*h/(b-m)+pas_K, pas_K) \ny_prey1 = np.zeros_like(Kplot1)                    \n\n## situation 2.\nKplot2 = np.arange(m*h/(b-m), h+2*m*h/(b-m)+pas_K, pas_K)\ny_prey2 = np.zeros_like(Kplot2)                    \ny_coex2 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K_p) for K_p in Kplot2]\n\n## situation 3.\nKplot3 = np.arange(h+2*m*h/(b-m), 8, pas_K/2)      \ny_prey3 = np.zeros_like(Kplot3)                    \ny_coex3 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K_p) for K_p in Kplot3]\n```\n\nReprésentation graphique :\n```{python}\n#| code-fold: true\n#| label: fig-bif-rma\n#| fig-cap: diagramme de bifurcation $y^*$ en fonction de $K$ pour le modèle de Rosenzweig MacArthur (@eq-rma)\n\nfig3, ax3 = plt.subplots(1, 1)  \nfig3.suptitle(\"Diagramme de bifurcations $y^*$ en fonction de $K$\",\n             va='top', fontsize='14')\n\n## tracé des différentes branches d'équilibres\n## situation 1.\nax3.plot(Kplot1, y_prey1, color = 'C2', label = \"équilibre stable\")\n\n## situation 2.\nax3.plot(Kplot2, y_prey2, color = 'C1', label = \"équilibre instable\")\nax3.plot(Kplot2, y_coex2, color = 'C2')\n\n## situation 3.\nax3.plot(Kplot3, y_prey3, color = 'C1')\nax3.plot(Kplot3, y_coex3, color = 'C1')\n\n## enluminures\nax3.set_ylabel('densité de prédateurs $y_\\infty$', fontsize='12')\nax3.set_xlabel('capacité de charge $K$', fontsize='12')\n\n## Type des bifurcations\nax3.text(2.2, 0.1, 'transcritique', fontsize='12')\nax3.text(5.15, 2.75, 'Hopf', fontsize='12')\n\nax3.grid()\n```\n\nOn aimerait pouvoir visualiser sur le diagramme de bifurcations l'amplitude du cycle limite attractif qui émerge de l'équilibre instable. Pour cela, on utilise une approche qui consiste à simuler pendant longtemps le système dynamique et récupérer les extrema de la trajectoire périodique pour ensuite les tracer (approche \"brute force\").\n\n```{python}\n## temps d'intégration du transitoire \"long\"\ntspan_transitoire = np.arange(t_0, 100*t_fin, pas_t)\n\n## array pour sauvegarder les extrema de la trajectoire périodique\ny_cycle_min = np.array([])\ny_cycle_max = np.array([])\n\nfor K_p in Kplot3:\n    ## on assigne le paramètre K à la valeur K_p\n    params_RMA_cycle = np.array([r, K_p, c, h, b, m])\n    \n    ## on simule le système pendant le transitoire\n    int_RMA_transitoire =  odeint(model_RMA, \n            etat0_RMA, tspan_transitoire, args=(params_RMA_cycle,), \n            hmax=pas_t)\n    \n    ## on resimule depuis la dernière valeur calculée \n    ## dans la simulation du transitoire\n    int_RMA_cycle = odeint(model_RMA, int_RMA_transitoire[-1, :], \n            tspan, args=(params_RMA_cycle,), hmax=pas_t)\n    \n    ## on sauvegarde les extremas dans y_cycle_min et \n    ## _max en appendant les array et les réassignant\n    y_cycle_min = np.append(y_cycle_min, np.min(int_RMA_cycle[:,1]))\n    y_cycle_max = np.append(y_cycle_max, np.max(int_RMA_cycle[:,1]))\n```\n\nIl ne reste plus qu'à tracer ces branches correspondant au cycle limite.\n\n```{python}\n#| label: fig-bif-rma-full\n#| fig-cap: diagramme de bifurcation $y^*$ en fonction de $K$ pour le modèle de Rosenzweig MacArthur (@eq-rma)\n\nax3.plot(Kplot3, y_cycle_min, color = 'C0', label = \"cycle limite attractif\")\nax3.plot(Kplot3, y_cycle_max, color = 'C0')\n\n## légende\nax3.legend(fontsize='10')\n\n## réafficher la figure\ndisplay(fig3)\n```\n\nThat's all folks!"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"pygments","reference-location":"margin","css":["styles.css"],"toc":true,"html-math-method":"katex","output-file":"pop_interactions.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.191","license":"CC BY-NC","bibliography":["references.bib"],"jupyter":"python3","theme":"cosmo","title":"Populations en interactions"},"extensions":{"book":{"multiFile":true}}}}}