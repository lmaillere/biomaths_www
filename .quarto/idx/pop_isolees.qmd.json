{"title":"Populations isolées","markdown":{"yaml":{"title":"Populations isolées"},"headingText":"Le modèle de Malthus","headingAttr":{"id":"sec-malthus","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n\nNous considérons le modèle proposé par @malthus :\n$$\n\\dot x = (n-m)x,\n$$ {#eq-malthus}\navec $n$ le taux de natalité, et $m$ le taux de mortalité.\n\n\nPour simuler ce modèle, c'est à dire intégrer numériquement les solutions au problème de Cauchy correspondant à l'@eq-malthus et $x(0)=x_0\\geq0$, nous allons utiliser les modules `numpy` et `matplotlib.pyplot`, et la méthode `odeint` de `scipy.integrate`.\n\n### Préliminaires\n\nOn commence par nettoyer l'espace de travail, dans Jupyter :\n```{python}\n%reset -f\n```\n\nEt on importe les modules cités précédemment :\n```{python}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom scipy.integrate import odeint\n```\n\n### Système dynamique\n\nDéfinissons le modèle: une fonction de l'état $x$, du temps $t$ (nécessaire pour `odeint`), de paramètres, qui renvoit la dérivée $\\dot x$.\n```{python}\ndef model_malthus(etat, t, params): \n    x = etat        # unpack l'etat\n    n, m = params   # unpack params -> params locaux \n    xdot = (n-m)*x  # calcule la derivee de l'etat \n    return xdot     # renvoit la derivée \n```\n\n::: {.callout-important}\nOn fera attention a bien désencapsuler les états/paramètres/*etc.* dans le même ordre que l'encapsulation faite dans le corps du programme (*cf.* ci-dessous).\n:::\n\n### Problème de Cauchy (initial value problem)\n\nDéfinissons les conditions initiales, et encapsulons le dans un `np.array` :\n```{python}\nx0 = 0.1\n\netat0_malthus = np.array([x0])\n```\nDéfinissons les paramètres et encapsulons les :\n```{python}\nn = 3.0     # taux de natalité\nm = 2.0     # taux de mortalité\n\nparams_malthus = np.array([n, m])\n```\nDéfinissons le temps d'intégration `tspan` (vecteur entre le temps initial et le temps final):\n```{python}\nt_0 = 0.0           # temps initial\nt_fin = 10.0        # temps final\npas_t = 0.01        # pas de temps \n\ntspan = np.arange(start=t_0, stop=t_fin, step=pas_t)\n```\n\n### Intégration\n\nIl s'agit d'utiliser la fonction `odeint` de `scipy` :\n```{python}\nint_malthus = odeint(\n                model_malthus,         # système dynamique\n                etat0_malthus,          # condition initiale\n                tspan,                  # temps d'intégration\n                args=(params_malthus,), # paramètres du syst. dyn. ici un tuple \n                                        ## à un élément (cf. virgule)\n                hmax=pas_t)             # pas d'intégration max. sur temps\n```\n::: {.callout-important}\nL'appel à `odeint` est très précis et doit respecter les règles et l'ordre indiqués ci-dessus.\n:::\n\nL'intégration est faite :\n```{python}\nint_malthus[:5]\n```\nIl reste à représenter graphiquement la solution calculée.\n\n### Représentation graphique\n\nCréons une figure et deux systèmes d'axes pour représenter deux sous-figures, puis traçons l'évolution de $x(t)$ calculée numériquement en fonction du temps (gauche) ou la *solution* mathématique $x(t)=e^{(n-m)t} x_0$ (droite). La représentation est visible dans la @fig-malthus.\n\nDécouvrons aussi différentes options des méthodes `subplots(), plot(), legend()`, l'utilisation de LaTeX dans les chaînes de caractères, ou les `fstrings` de Python 3 pour compléter les chaines de caractères avec des valeurs via `\"\".format()`.\n```{python}\n#| label: fig-malthus\n#| fig-cap: simulation et solution mathématique du modèle de Malthus (@eq-malthus)\n\n## figure et systèmes d'axes\nfig1, (ax1, ax2) = plt.subplots(1, 2, figsize=(9, 6))  \n\n## titre de la figure\nfig1.suptitle('Simulation du modèle de Malthus\\n $n = {}, m = {}$'.format(n, m), \n              va='top', fontsize='14')\n\n## premier subplot\nax1.plot(tspan, int_malthus, \n         color='C0', \n         label='$x(t)$ (numérique)')\n\n## modification des bornes\nax1.set_ylim(bottom=None, top=None)\n\n## axes / légendes / grille\nax1.legend(fontsize='10')\nax1.set_xlabel('Temps $t$', fontsize='12')\nax1.set_ylabel('Densité de population $x$', fontsize='12')\nax1.grid()\n\n\n## second subplot\nax2.plot(tspan, np.exp((n-m)*tspan)*x0, \n         color='C2', \n         label='$x(t)$ (analytique)')\n\n## axes / légendes / grille\nax2.legend(fontsize='10')\nax2.set_xlabel('Temps $t$', fontsize='12')\nax2.grid()\n```\n\n::: {.callout-warning}\nMalgré une bonne précision d'intégration, une simulation/intégration numérique reste une approximation des solutions mathématiques, et par construction induit donc des erreurs, comme l'illustre la @fig-erreur-malthus.\n:::\n\n```{python}\n#| label: fig-erreur-malthus\n#| fig-cap: Erreur à l'intégration numérique du modèle de Malthus (@eq-malthus)\n#| code-fold: true\n\nfig2, ax3 = plt.subplots(1, 1, figsize=(6, 4))\nax3.plot(tspan, \n         int_malthus[:,0]-np.exp((n-m)*tspan)*x0, \n         color='C1', \n         label='$x(t)$ (numérique)')\n\nfig2.suptitle('Erreur d\\'intégration pour le modèle de Malthus', \n            va='top', fontsize='14')\nax3.set_xlabel('Temps $t$', fontsize='12')\nax3.set_ylabel('Erreur d\\'intégration', fontsize='12')\nax3.grid()\n```\n\n\n## Le modèle logistique {#sec-logistic}\n\nNous considérons ici le modèle \"logistique\" proposé par @verhulst1938 :\n\n$$\n\\dot x = r x \\left(1-\\frac{x}{K}\\right),\n$$ {#eq-logistic}\navec $r$ le taux de croissance intrinsèque de la population et $K$ la capacité de charge de l'environnement.\n\n\nIl n'y a pas de difficulté particulière par rapport aux simulations précedentes. On commence par nettoyer l'espace de travail, puis ré-importer les modules nécessaires :\n\n```{python}\n%reset -f\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n```\n\nLa définition du modèle, des conditions initiales et paramètres, l'intégration et la représentation graphique suivent les étapes vues précédemment.\n\n\n### Simulation\n\n- Définition du système dynamique :\n\n```{python}\n#| code-fold: true\n\ndef model_logistic(etat, t, params): \n    x = etat        \n    r, K = params   \n    xdot = r*x*(1-x/K)  \n    return xdot     \n```\n\n- Condition initiale, paramètres, `tspan` :\n\n```{python}\n#| code-fold: true\n\n## condition initiale\nx0 = 0.1\netat0_logistic = np.array([x0])\n\n## paramètres\nr = 1.0     # taux de croissance intrinsèque\nK = 10.0    # capacité de charge\nparams_logistic = np.array([r, K])\n\n## tspan\nt_0 = 0.0           \nt_fin = 10.0        \npas_t = 0.01        \ntspan = np.arange(t_0, t_fin, pas_t)\n```\n\n- Intégration :\n\n```{python}\n#| code-fold: true\n\nint_logistic = odeint(\n                model_logistic,        \n                etat0_logistic,         \n                tspan,                  \n                args=(params_logistic,),\n                hmax=pas_t)             \n```\n\n### Représentation graphique\n\n```{python}\n#| code-fold: true\n#| label: fig-logistic\n#| fig-cap: simulation du modèle logistique (@eq-logistic)\n\n## figure et systèmes d'axes\nfig, ax = plt.subplots(1, 1)  \n\n## titre de la figure\nfig.suptitle('Simulation du modèle logistique ; $r = {}, K = {}$'.format(r, K), \n              va='top', fontsize='14')\n\n## simulation\nax.plot(tspan, int_logistic, \n         color='C0', \n         label='$x(t)$') # solution\n\n## équilibres\nax.plot(tspan, np.zeros_like(tspan),\n        color = 'C3',\n        linestyle = 'dashed',\n        label = \"équilibre instable\")\nax.plot(tspan, np.ones_like(tspan)*K,\n        color = 'C2',\n        linestyle = 'dashed',\n        label = \"équilibre stable\")\n\n## modification des bornes\nax.set_ylim(bottom=None, top=None)\n\n## axes / légendes / grille\nax.legend(fontsize='10')\nax.set_xlabel('Temps $t$', fontsize='12')\nax.set_ylabel('Densité de population $x$', fontsize='12')\nax.grid()\n```\n\n## Effets Allee {#sec-allee}\n\nOn s'intéresse à un modèle de dynamique de population avec \"effets Allee forts\", souvent attribué à @gruntfest1997^[mais de nombreuses variations de cette forme polynomiale existent dans la littérature depuis @bazykin1985] :\n\n$$\n\\dot x = r x \\left(\\frac{x}{\\epsilon}-1\\right)\\left(1-\\frac{x}{K}\\right),\n$$ {#eq-allee}\navec $r$ le taux de croissance intrinsèque de la population (par analogie avec la logistique), $K$ la capcité de charge de l'environnement et $\\epsilon$ le seuil en dessous duquel la population n'est pas viable ('seuil de Allee'). On procède comme ci-dessus.\n\n### Simulation : préliminaires\n\n- nettoyage de l'espace de travail et chargement des modules :\n\n```{python}\n#| code-fold: true\n%reset -f\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n```\n\n- Définition du système dynamique :\n\n```{python}\n#| code-fold: true\n\ndef model_allee(etat, t, params): \n    x = etat        \n    r, K, epsilon = params   \n    xdot = r*x*(x/epsilon-1)*(1-x/K)  \n    return xdot     \n```\n\n- Paramètres, `tspan` :\n\n```{python}\n#| code-fold: true\n\n## paramètres\nr = 1.0       # taux de croissance intrinsèque\nepsilon = 2.0 # seuil de Allee\nK = 10.0      # capacité de charge\nparams_allee = np.array([r, K, epsilon])\n\n## tspan\nt_0 = 0.0           \nt_fin = 3.0        \npas_t = 0.01        \ntspan = np.arange(t_0, t_fin, pas_t)\n```\n\n### Simulation : conditions initiales multiples\n\nPour mettre en valeur la bi-stabilité du système dynamique défini par l'@eq-allee, nous créons une fonction qui intègre le problème de Cauchy depuis une condition initiale donnée.\n\n```{python}\ndef int_allee(x0, tspan=tspan, params=params_allee):\n    sim_allee = odeint(\n                model_allee,        \n                x0,             # argument de la fonction \n                tspan,          # argument de la fonction \n                args=(params,), # argument de la fonction \n                hmax=pas_t)\n    return sim_allee\n```\n\n::: {.callout-note}\nNous remarquons l'utilisation de `kwargs` (keyword arguments `tspan` et `params`), des arguments qui prendront leur valeur par défaut si ils ne sont pas re-spécifiés dans l'appel de la fonction `int_allee()`.\n:::\n\nVérifions que la fonction réalise bien ce qui est attendu :\n\n```{python}\nint_allee(0.1)[:5,0]\n```\n\n### Représentation graphique\n\nL'idée est de représenter plusieurs trajectoires issues de plusieurs conditions initiales. Créons un `array` de conditions initiales :\n\n```{python}\nx0_step = 1.35\nx0_arr = np.arange(x0_step, K, x0_step)\n```\n\nPuis nous faisons la représentation graphique via une boucle exploitant la fonction `int_allee()` :\n\n```{python}\n#| label: fig-allee\n#| fig-cap: simulation du modèle avec effets Allee forts (@eq-allee)\nfig, ax = plt.subplots(1, 1)  \nfig.suptitle('Simulation du modèle avec effets Allee'\\\n    '; $r={}, K={}, \\epsilon={}$'.format(r, K, epsilon), \n              va='top', fontsize='14')\n\n## redéfinition du cycle des couleurs pour un dégradé de bleu\ncolorAllee = plt.cm.Blues(np.linspace(.8, .3, x0_arr.shape[0]))\nax.set_prop_cycle(color = colorAllee)\n\n## simulations\nax.plot(tspan, int_allee(x0_arr[0]),\n        label = \"$x(t)$\")\nfor x0 in x0_arr[1:]:       # x0 parcour x0_arr\n    ax.plot(tspan, int_allee(x0)) \n\n## équilibres\nax.plot(tspan, np.zeros_like(tspan),\n        color = 'C2',\n        linestyle = 'dashed',\n        label = \"équilibre stable\")\nax.plot(tspan, np.ones_like(tspan)*K,\n        color = 'C2',\n        linestyle = 'dashed')\nax.plot(tspan, np.ones_like(tspan)*epsilon,\n        color = 'C3',\n        linestyle = 'dashed',\n        label = \"équilibre instable\")\n\n## axes / légendes / grille\nax.legend(fontsize='10')\nax.set_xlabel('Temps $t$', fontsize='12')\nax.set_ylabel('Densité de population $x$', fontsize='12')\nax.grid()\n```\n\n::: {.callout-note}\nNous utilisons une boucle avec `x0` parcourant les conditions initiales `x0_arr` pour tracer les différentes solutions. \n:::\n\n::: {.callout-note}\nLe dégradé de bleu des simulations est obtenu en créant une `colormap` à partir de `plt.cm.Blues()` ayant pour argument un `array` à valeurs dans $[0,1]$, de la même taille que le nombre de courbes à tracer. Cette `colormap` redéfini ensuite le cycle de couleurs du système d'axes via `ax.set_prop_cycle(color = foo)`.\n:::\n\nLa suite sur les populations exploitées [par-ici](pop_exploitees.qmd).\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"pygments","reference-location":"margin","css":["styles.css"],"toc":true,"html-math-method":"katex","output-file":"pop_isolees.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.191","license":"CC BY-NC","bibliography":["references.bib"],"jupyter":"python3","theme":"cosmo","title":"Populations isolées"},"extensions":{"book":{"multiFile":true}}}}}