{
  "hash": "240b4d2e5af6ec871deaa5d242d1d18e",
  "result": {
    "markdown": "---\ntitle: \"Populations isolées\"\n---\n\n## Le modèle de Malthus {#sec-malthus}\n\nNous considérons le modèle proposé par @malthus :\n$$\n\\dot x = (n-m)x,\n$$ {#eq-malthus}\navec $n$ le taux de natalité, et $m$ le taux de mortalité.\n\n\nPour simuler ce modèle, c'est à dire intégrer numériquement les solutions au problème de Cauchy correspondant à l'@eq-malthus et $x(0)=x_0\\geq0$, nous allons utiliser les modules `numpy` et `matplotlib.pyplot`, et la méthode `odeint` de `scipy.integrate`.\n\n### Préliminaires\n\nOn commence par nettoyer l'espace de travail, dans Jupyter :\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n%reset -f\n```\n:::\n\n\nEt on importe les modules cités précédemment :\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom scipy.integrate import odeint\n```\n:::\n\n\n### Système dynamique\n\nDéfinissons le modèle: une fonction de l'état $x$, du temps $t$ (nécessaire pour `odeint`), de paramètres, qui renvoit la dérivée $\\dot x$.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef model_malthus(etat, t, params): \n    x = etat        # unpack l'etat\n    n, m = params   # unpack params -> params locaux \n    xdot = (n-m)*x  # calcule la derivee de l'etat \n    return xdot     # renvoit la derivée \n```\n:::\n\n\n::: {.callout-important}\nOn fera attention a bien désencapsuler les états/paramètres/*etc.* dans le même ordre que l'encapsulation faite dans le corps du programme (*cf.* ci-dessous).\n:::\n\n### Problème de Cauchy (initial value problem)\n\nDéfinissons les conditions initiales, et encapsulons le dans un `np.array` :\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nx0 = 0.1\n\netat0_malthus = np.array([x0])\n```\n:::\n\n\nDéfinissons les paramètres et encapsulons les :\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nn = 3.0     # taux de natalité\nm = 2.0     # taux de mortalité\n\nparams_malthus = np.array([n, m])\n```\n:::\n\n\nDéfinissons le temps d'intégration `tspan` (vecteur entre le temps initial et le temps final):\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nt_0 = 0.0           # temps initial\nt_fin = 10.0        # temps final\npas_t = 0.01        # pas de temps \n\ntspan = np.arange(start=t_0, stop=t_fin, step=pas_t)\n```\n:::\n\n\n### Intégration\n\nIl s'agit d'utiliser la fonction `odeint` de `scipy` :\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nint_malthus = odeint(\n                model_malthus,         # système dynamique\n                etat0_malthus,          # condition initiale\n                tspan,                  # temps d'intégration\n                args=(params_malthus,), # paramètres du syst. dyn. ici un tuple \n                                        ## à un élément (cf. virgule)\n                hmax=pas_t)             # pas d'intégration max. sur temps\n```\n:::\n\n\n::: {.callout-important}\nL'appel à `odeint` est très précis et doit respecter les règles et l'ordre indiqués ci-dessus.\n:::\n\nL'intégration est faite :\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nint_malthus[:5]\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\narray([[0.1       ],\n       [0.10100502],\n       [0.10202014],\n       [0.10304547],\n       [0.10408109]])\n```\n:::\n:::\n\n\nIl reste à représenter graphiquement la solution calculée.\n\n### Représentation graphique\n\nCréons une figure et deux systèmes d'axes pour représenter deux sous-figures, puis traçons l'évolution de $x(t)$ calculée numériquement en fonction du temps (gauche) ou la *solution* mathématique $x(t)=e^{(n-m)t} x_0$ (droite). La représentation est visible dans la @fig-malthus.\n\nDécouvrons aussi différentes options des méthodes `subplots(), plot(), legend()`, l'utilisation de LaTeX dans les chaînes de caractères, ou les `fstrings` de Python 3 pour compléter les chaines de caractères avec des valeurs via `\"\".format()`.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n## figure et systèmes d'axes\nfig1, (ax1, ax2) = plt.subplots(1, 2)  \n\n## titre de la figure\nfig1.suptitle('Simulation du modèle de Malthus\\n $n = {}, m = {}$'.format(n, m), \n              va='top', fontsize='14')\n\n## premier subplot\nax1.plot(tspan, int_malthus, \n         color='C0', \n         label='$x(t)$ (numérique)')\n\n## modification des bornes\nax1.set_ylim(bottom=None, top=None)\n\n## axes / légendes / grille\nax1.legend(fontsize='10')\nax1.set_xlabel('Temps $t$', fontsize='12')\nax1.set_ylabel('Densité de population $x$', fontsize='12')\nax1.grid()\n\n\n## second subplot\nax2.plot(tspan, np.exp((n-m)*tspan)*x0, \n         color='C2', \n         label='$x(t)$ (analytique)')\n\n## axes / légendes / grille\nax2.legend(fontsize='10')\nax2.set_xlabel('Temps $t$', fontsize='12')\nax2.grid()\n```\n\n::: {.cell-output .cell-output-display}\n![simulation et solution mathématique du modèle de Malthus (@eq-malthus)](pop_isolees_files/figure-html/fig-malthus-output-1.png){#fig-malthus width=611 height=481}\n:::\n:::\n\n\n::: {.callout-warning}\nMalgré une bonne précision d'intégration, une simulation/intégration numérique reste une approximation des solutions mathématiques, et par construction induit donc des erreurs, comme l'illustre la @fig-erreur-malthus.\n:::\n\n::: {.cell execution_count=10}\n``` {.python .cell-code code-fold=\"true\"}\nfig2, ax3 = plt.subplots(1, 1)\nax3.plot(tspan, \n         int_malthus[:,0]-np.exp((n-m)*tspan)*x0, \n         color='C1', \n         label='$x(t)$ (numérique)')\n\nfig2.suptitle('Erreur d\\'intégration pour le modèle de Malthus', \n            va='top', fontsize='14')\nax3.set_xlabel('Temps $t$', fontsize='12')\nax3.set_ylabel('Erreur d\\'intégration', fontsize='12')\nax3.grid()\n```\n\n::: {.cell-output .cell-output-display}\n![Erreur à l'intégration numérique du modèle de Malthus (@eq-malthus)](pop_isolees_files/figure-html/fig-erreur-malthus-output-1.png){#fig-erreur-malthus width=626 height=481}\n:::\n:::\n\n\n## Le modèle logistique {#sec-logistic}\n\nNous considérons ici le modèle \"logistique\" proposé par @verhulst1938 :\n\n$$\n\\dot x = r x \\left(1-\\frac{x}{K}\\right),\n$$ {#eq-logistic}\navec $r$ le taux de croissance intrinsèque de la population et $K$ la capacité de charge de l'environnement.\n\n\nIl n'y a pas de difficulté particulière par rapport aux simulations précedentes. On commence par nettoyer l'espace de travail, puis ré-importer les modules nécessaires :\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n%reset -f\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n```\n:::\n\n\nLa définition du modèle, des conditions initiales et paramètres, l'intégration et la représentation graphique suivent les étapes vues précédemment.\n\n\n### Simulation\n\n- Définition du système dynamique :\n\n::: {.cell execution_count=12}\n``` {.python .cell-code code-fold=\"true\"}\ndef model_logistic(etat, t, params): \n    x = etat        \n    r, K = params   \n    xdot = r*x*(1-x/K)  \n    return xdot     \n```\n:::\n\n\n- Condition initiale, paramètres, `tspan` :\n\n::: {.cell execution_count=13}\n``` {.python .cell-code code-fold=\"true\"}\n## condition initiale\nx0 = 0.1\netat0_logistic = np.array([x0])\n\n## paramètres\nr = 1.0     # taux de croissance intrinsèque\nK = 10.0    # capacité de charge\nparams_logistic = np.array([r, K])\n\n## tspan\nt_0 = 0.0           \nt_fin = 10.0        \npas_t = 0.01        \ntspan = np.arange(t_0, t_fin, pas_t)\n```\n:::\n\n\n- Intégration :\n\n::: {.cell execution_count=14}\n``` {.python .cell-code code-fold=\"true\"}\nint_logistic = odeint(\n                model_logistic,        \n                etat0_logistic,         \n                tspan,                  \n                args=(params_logistic,),\n                hmax=pas_t)             \n```\n:::\n\n\n### Représentation graphique\n\n::: {.cell execution_count=15}\n``` {.python .cell-code code-fold=\"true\"}\n## figure et systèmes d'axes\nfig, ax = plt.subplots(1, 1)  \n\n## titre de la figure\nfig.suptitle('Simulation du modèle logistique ; $r = {}, K = {}$'.format(r, K), \n              va='top', fontsize='14')\n\n## simulation\nax.plot(tspan, int_logistic, \n         color='C0', \n         label='$x(t)$') # solution\n\n## équilibres\nax.plot(tspan, np.zeros_like(tspan),\n        color = 'C3',\n        linestyle = 'dashed',\n        label = \"équilibre instable\")\nax.plot(tspan, np.ones_like(tspan)*K,\n        color = 'C2',\n        linestyle = 'dashed',\n        label = \"équilibre stable\")\n\n## modification des bornes\nax.set_ylim(bottom=None, top=None)\n\n## axes / légendes / grille\nax.legend(fontsize='10')\nax.set_xlabel('Temps $t$', fontsize='12')\nax.set_ylabel('Densité de population $x$', fontsize='12')\nax.grid()\n```\n\n::: {.cell-output .cell-output-display}\n![simulation du modèle logistique (@eq-logistic)](pop_isolees_files/figure-html/fig-logistic-output-1.png){#fig-logistic width=590 height=481}\n:::\n:::\n\n\n## Effets Allee {#sec-allee}\n\nOn s'intéresse à un modèle de dynamique de population avec \"effets Allee forts\", souvent attribué à @gruntfest1997^[mais de nombreuses variations de cette forme polynomiale existent dans la littérature depuis @bazykin1985] :\n\n$$\n\\dot x = r x \\left(\\frac{x}{\\epsilon}-1\\right)\\left(1-\\frac{x}{K}\\right),\n$$ {#eq-allee}\navec $r$ le taux de croissance intrinsèque de la population (par analogie avec la logistique), $K$ la capcité de charge de l'environnement et $\\epsilon$ le seuil en dessous duquel la population n'est pas viable ('seuil de Allee'). On procède comme ci-dessus.\n\n### Simulation : préliminaires\n\n- nettoyage de l'espace de travail et chargement des modules :\n\n::: {.cell execution_count=16}\n``` {.python .cell-code code-fold=\"true\"}\n%reset -f\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n```\n:::\n\n\n- Définition du système dynamique :\n\n::: {.cell execution_count=17}\n``` {.python .cell-code code-fold=\"true\"}\ndef model_allee(etat, t, params): \n    x = etat        \n    r, K, epsilon = params   \n    xdot = r*x*(x/epsilon-1)*(1-x/K)  \n    return xdot     \n```\n:::\n\n\n- Paramètres, `tspan` :\n\n::: {.cell execution_count=18}\n``` {.python .cell-code code-fold=\"true\"}\n## paramètres\nr = 1.0       # taux de croissance intrinsèque\nepsilon = 2.0 # seuil de Allee\nK = 10.0      # capacité de charge\nparams_allee = np.array([r, K, epsilon])\n\n## tspan\nt_0 = 0.0           \nt_fin = 3.0        \npas_t = 0.01        \ntspan = np.arange(t_0, t_fin, pas_t)\n```\n:::\n\n\n### Simulation : conditions initiales multiples\n\nPour mettre en valeur la bi-stabilité du système dynamique défini par l'@eq-allee, nous créons une fonction qui intègre le problème de Cauchy depuis une condition initiale donnée.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ndef int_allee(x0, tspan=tspan, params=params_allee):\n    sim_allee = odeint(\n                model_allee,        \n                x0,             # argument de la fonction \n                tspan,          # argument de la fonction \n                args=(params,), # argument de la fonction \n                hmax=pas_t)\n    return sim_allee\n```\n:::\n\n\n::: {.callout-note}\nNous remarquons l'utilisation de `kwargs` (keyword arguments `tspan` et `params`), des arguments qui prendront leur valeur par défaut si ils ne sont pas re-spécifiés dans l'appel de la fonction `int_allee()`.\n:::\n\nVérifions que la fonction réalise bien ce qui est attendu :\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nint_allee(0.1)[:5,0]\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\narray([0.1       , 0.09906363, 0.09813549, 0.09721551, 0.09630365])\n```\n:::\n:::\n\n\n### Représentation graphique\n\nL'idée est de représenter plusieurs trajectoires issues de plusieurs conditions initiales. Créons un `array` de conditions initiales :\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nx0_step = 1.35\nx0_arr = np.arange(x0_step, K, x0_step)\n```\n:::\n\n\nPuis nous faisons la représentation graphique via une boucle exploitant la fonction `int_allee()` :\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nfig, ax = plt.subplots(1, 1)  \nfig.suptitle('Simulation du modèle avec effets Allee'\\\n    '; $r={}, K={}, \\epsilon={}$'.format(r, K, epsilon), \n              va='top', fontsize='14')\n\n## redéfinition du cycle des couleurs pour un dégradé de bleu\ncolorAllee = plt.cm.Blues(np.linspace(.8, .3, x0_arr.shape[0]))\nax.set_prop_cycle(color = colorAllee)\n\n## simulations\nax.plot(tspan, int_allee(x0_arr[0]),\n        label = \"$x(t)$\")\nfor x0 in x0_arr[1:]:       # x0 parcour x0_arr\n    ax.plot(tspan, int_allee(x0)) \n\n## équilibres\nax.plot(tspan, np.zeros_like(tspan),\n        color = 'C2',\n        linestyle = 'dashed',\n        label = \"équilibre stable\")\nax.plot(tspan, np.ones_like(tspan)*K,\n        color = 'C2',\n        linestyle = 'dashed')\nax.plot(tspan, np.ones_like(tspan)*epsilon,\n        color = 'C3',\n        linestyle = 'dashed',\n        label = \"équilibre instable\")\n\n## axes / légendes / grille\nax.legend(fontsize='10')\nax.set_xlabel('Temps $t$', fontsize='12')\nax.set_ylabel('Densité de population $x$', fontsize='12')\nax.grid()\n```\n\n::: {.cell-output .cell-output-display}\n![simulation du modèle avec effets Allee forts (@eq-allee)](pop_isolees_files/figure-html/fig-allee-output-1.png){#fig-allee width=620 height=481}\n:::\n:::\n\n\n::: {.callout-note}\nNous utilisons une boucle avec `x0` parcourant les conditions initiales `x0_arr` pour tracer les différentes solutions. \n:::\n\n::: {.callout-note}\nLe dégradé de bleu des simulations est obtenu en créant une `colormap` à partir de `plt.cm.Blues()` ayant pour argument un `array` à valeurs dans $[0,1]$, de la même taille que le nombre de courbes à tracer. Cette `colormap` redéfini ensuite le cycle de couleurs du système d'axes via `ax.set_prop_cycle(color = foo)`.\n:::\n\nLa suite sur les populations exploitées [par-ici](pop_exploitees.qmd).\n\n",
    "supporting": [
      "pop_isolees_files"
    ],
    "filters": [],
    "includes": {}
  }
}