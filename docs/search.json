[
  {
    "objectID": "pop_interactions.html",
    "href": "pop_interactions.html",
    "title": "Populations en interactions",
    "section": "",
    "text": "Nous considérons le modèle de dynamique de populations de Lotka (1925) et Volterra (1926) :\n\n\\left\\{\\begin{array}{l}\n\\dot x = rx - c xy,\\\\\n\\dot y = bxy - m y.\n\\end{array}\\right.\n\\tag{1}\n\n\nIl n’y a pas de difficulté particulière à la simulation par rapport au modèle de la tordeuse du bourgeon de l’épinette avec population d’oiseaux variables.\n\n\nCode\n## on nettoie l'espace de travail et on reload les modules\n%reset -f\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n \n## densités initiales des populations\nx0 = 1\ny0 = 2.5\netat0_LV = np.array([x0, y0])\n\n## tspan\nt_0 = 0             \nt_fin = 30.0        \npas_t = 0.01        \ntspan = np.arange(t_0, t_fin, pas_t)\n\n## paramètres du modèle\nr = 1.0\nc = 1.0\nb = 1.0\nm = 1.0\nparams_LV = np.array([r, c, b, m])\n\n## définition du modèle de Lotka Volterra\ndef model_LV(etat, t, params):\n    x, y = etat                       # recupere les variables d'etat\n    r, c, b, m = params               # recupere les parametres \n    etatdot = [r*x - c*x*y,           # dot x\n               b*x*y - m*y]           # dot y\n    return etatdot                    # renvoie la derivee\n\n## simulation proprement dite\nint_LV = odeint(model_LV, etat0_LV, tspan, args=(params_LV,), hmax=pas_t)\n\n\nReprésentation graphique contre le temps :\n\n\nCode\n## création d'une figure, et d'un système d'axe\nfig1, ax1 = plt.subplots(1, 1)  \n\nfig1.suptitle(\"Dynamiques Proies - Prédateurs modèle de Lotka Volterra\",\n             va='top', fontsize='14')\n\n## tracé de x et y contre le temps\nax1.plot(tspan, int_LV[:, 0], color = 'C0', label = \"proies $x$\")\nax1.plot(tspan, int_LV[:, 1], color = 'C1', label = \"prédateurs $y$\")\n\n## axes & co\nax1.set_xlabel('Temps', fontsize='12')\nax1.set_ylabel('Densités de populations', fontsize='12')\nax1.legend()\nax1.grid()\n\n\n\n\n\nFigure 1: dynamiques des proies et prédateurs contre le temps dans le modèle de Lotka et Volterra (Equation 1)\n\n\n\n\n\n\n\nIl est intéressant de représenter les trajectoires dans l’espace d’état (x,y), en combinaison avec une analyse qualitative du plan de phase (isoclines nulles, équilibres), une représentation du champs de vecteurs et de quelques morceaux de trajectoires sur le plan.\nCommençons par calculer les isoclines nulles et les équilibres.\n\n\nCode\n## array annexes pour le calcul et la représentation des isoclines nulles\nxplot = np.arange(0, 3, .1)  \nyplot = np.arange(0, 3, .1)\n\n## isoclines nulles de xdot\nnull_x_x = np.zeros_like(yplot)        # x = 0 isocline nulle de xdot\nnull_x_y = np.ones_like(xplot)*(r/c)   # y = r/c isocline nulle de xdot\n\n## isoclines nulles de ydot\nnull_y_y = np.zeros_like(xplot)        # y = 0 isocline nulle de ydot\nnull_y_x = np.ones_like(yplot)*(m/b)   # x = m/b isocline nulle de ydot\n\n## équilibres\neq_extinct = [0, 0]\neq_coex = [r/c, m/b]\n\n\nPuis on trace le plan de phase.\n\n\nCode\n## création d'une figure, et d'un système d'axe\nfig2, ax2 = plt.subplots(1, 1)  \n\n## titre de la figure\nfig2.suptitle(\"Dynamiques Proies - Prédateurs modèle de Lotka Volterra\", \n            va='top', fontsize='14')\n\n## isoclines nulles \nax2.plot(null_x_x, yplot, color = 'C2')\nax2.plot(xplot, null_x_y, color = 'C2', label = \"isoclines nulles de $\\dot x$\")\nax2.plot(xplot, null_y_y, color = 'C1')\nax2.plot(null_y_x, yplot, color = 'C1', label = \"isoclines nulles de $\\dot y$\")\n\n## équilibres\nax2.plot(eq_extinct[0], eq_extinct[1], marker ='.', color = 'C3', markersize = 16)\nax2.plot(eq_coex[0], eq_coex[1], marker ='.', \n        color = 'C0', markersize = 16)\n## trajectoires\nax2.plot(int_LV[:, 0], int_LV[:, 1], color = 'C0', label = \"trajectoire\")\n\n## enluminures\nax2.set_xlabel('Proies $x$', fontsize='12')\nax2.set_ylabel('Prédateurs $y$', fontsize='12')\nax2.legend(fontsize='10', loc = \"upper right\")\n\n## modification éventuelle des bornes des axes\nax2.set_ylim(bottom=-.2, top=None)\nax2.set_xlim(left=-.2, right=None);\n\n\n\n\n\nFigure 2: plan de phase du modèle proies-prédateurs de Lotka Volterra (Equation 1)\n\n\n\n\nComplètons ce plan de phase avec l’orientation du champs de vecteurs (fonction quiver) et des échantillons de trajectoires (fonction streamplot). Ces représentations reposent sur la définition d’une grille de coordonnées sur le plan, via une meshgrid.\n\n## définition de l'échantillonnage selon $x$ et $y$\nx_grid = np.linspace(0.1, 3.0, 10)   # au passage on change un peu de np.arange()\ny_grid = np.linspace(0.1, 3.0, 10)\n\n## grille X,Y selon x_grid et y_grid\nX, Y = np.meshgrid(x_grid, y_grid)\n\nSur cette grille, on calcule les dérivées \\dot x et \\dot y :\n\ndx, dy = model_LV([X, Y], 0, params_LV)\n\nEt on peut compléter le plan de phase :\n\n## tracé du champs de vecteur\nax2.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', width = .002)\n\n## tracé des échantillons de trajectoires\nax2.streamplot(X, Y, dx, dy, density = 0.4, maxlength = 0.25, color = \"purple\")\n\ndisplay(fig2)\n\n\n\n\nFigure 3: plan de phase du modèle proies-prédateurs de Lotka Volterra\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nAttention à l’option angles ='xy' de quiver: les flèches sont ainsi tracées avec orientation en unité naturelle de l’écran et pas en unité naturelle de la figure qui est le comportement par défaut de la méthode (qui n’est pas naturel).\n\n\n\n\n\nFinalement on peut représenter l’intégrale première de ce système. Commençons par la définir selon les calculs faits en cours :\n\nH(x,y) = -r\\log(y)+ c y - m \\log(x) + b x.\n\n\ndef int_premiere(etat, params):\n    x, y = etat                       \n    r, c, b, m = params               \n    H_xy = -r*np.log(y) + c*y - m*np.log(x) + b*x  \n    return H_xy\n\nEffectuons une représentation graphique en 3D dans l’espace (x, y, H), ce qui fournit un visuel intéressant.\nPour celà nous avons besoin d’une meshgrid plus précise que celle définie plus haut.\n\n\nCode\nx_grid = np.linspace(0.15, 3.0, 30)   \ny_grid = np.linspace(0.15, 3.0, 30)\nX, Y = np.meshgrid(x_grid, y_grid)\n\n\n\nfig3, ax3 = plt.subplots(1, 1, subplot_kw={\"projection\": \"3d\"})  \n\n## colormaps\nfrom matplotlib import cm\n\n## intégrale première sur la grille X, Y\nax3.plot_surface(X, Y, int_premiere([X, Y], params_LV),\n             cmap=cm.viridis, antialiased=True, alpha =.7)\n\n## réglage de l'angle de vision en fonction de l'élévation et de l'azimut\nax3.view_init(elev=10, azim= 30)\n\n## labellisation des axes\nax3.set_xlabel('Proies $x$', fontsize='12')\nax3.set_ylabel('Prédateurs $y$', fontsize='12')\nax3.set_zlabel('Intégrale première', fontsize='12')\n\nax3.set_yticklabels([])\nax3.set_xticklabels([])\nax3.set_zticklabels([])\nfig3.suptitle(\"Intégrale première\\n modèle de Lotka Volterra\", \n            va='top', fontsize='14');\n\n\n\n\nFigure 4: intégrale première du modèle proies prédateurs de Lotka Volterra (Equation 1)\n\n\n\n\nOn rajoute la trajectoire et la valeur H(x,y) = H(x_0, y_0) :\n\n## H(x,y) = H(x0,y0)\nax3.plot_surface(X, Y, \n                np.ones_like(X)*int_premiere([x0, y0], params_LV), \n                antialiased=True, alpha =.3)\n\n## trajectoire\nax3.plot(int_LV[:,0], int_LV[:,1], \n         int_premiere([int_LV[:,0], int_LV[:,1]], params_LV), \n         color = \"red\", linewidth = 3)\n\ndisplay(fig3)\n\n\n\n\nFigure 5: intégrale première du modèle proies prédateurs de Lotka Volterra (Equation 1)"
  },
  {
    "objectID": "pop_interactions.html#sec-rma",
    "href": "pop_interactions.html#sec-rma",
    "title": "Populations en interactions",
    "section": "Le modèle de Rosenzweig MacArthur",
    "text": "Le modèle de Rosenzweig MacArthur\nNous considérons le modèle de dynamique de populations attribué à Rosenzweig et MacArthur (voir Rosenzweig and MacArthur (1963), Turchin (2003), Smith (2008)).\n\n\\left\\{\\begin{array}{l}\n\\dot x = \\displaystyle rx\\left(1-\\frac{x}{K}\\right) - c \\frac{x}{h+x} y\\\\[.3cm]\n\\dot y = b\\displaystyle \\frac{x}{h+x} y - m y\n\\end{array}\\right.\n\\tag{2}\n\nDynamiques et plan de phase\nIl n’y a pas de difficulté particulière à la simulation par rapport au modèle de Lotka Volterra.\n\n\nCode\n%reset -f\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\n## densités initiales des populations\nx0 = 1\ny0 = 2.5\netat0_RMA = np.array([x0, y0])\n\n## tspan \nt_0 = 0             \nt_fin = 80.0        \npas_t = 0.01         \ntspan = np.arange(t_0, t_fin, pas_t)\n\n## paramètres (il y a un cycle limite attractif pour ces valeurs)\nr = 1.0\nK = 10\nc = 1.0\nh = 2.0\nb = 2.0\nm = 1.0\nparams_RMA = np.array([r, K, c, h, b, m])\n\n## modèle \ndef model_RMA(etat, t, params):\n    x, y = etat                               \n    r, K, c, h, b, m = params               \n    etatdot = [r*x*(1-x/K) - c*x/(h+x)*y,   \n               b*x/(h+x)*y - m*y]       \n    return etatdot                     \n\n## simulation \nint_RMA = odeint(model_RMA, etat0_RMA, tspan, args=(params_RMA,), hmax=pas_t)\n\n\nReprésentation graphique des trajectoires contre le temps :\n\n\nCode\nfig1, ax1 = plt.subplots(1, 1)  \nfig1.suptitle(\"Dynamiques du modèle de Rosenzweig - MacArthur\", \n            va='top', fontsize='14')\n\n## tracé de x et y contre le temps\nax1.plot(tspan, int_RMA[:, 0], color = 'C0', label = \"proies $x$\")\nax1.plot(tspan, int_RMA[:, 1], color = 'C1', label = \"prédateurs $y$\")\n\n## enluminures\nax1.set_xlabel('temps', fontsize='12')\nax1.set_ylabel('densités de populations', fontsize='12')\nax1.legend(fontsize='10')\nax1.grid()\n\n\n\n\n\nFigure 6: simulation des trajectoires du modèle de Rosenzweig et MacArthur (Equation 2)\n\n\n\n\nReprésentation graphique dans le plan de phase :\n\n\nCode\nfig2, ax2 = plt.subplots(1, 1)  \nfig2.suptitle(\"Plan de phase du modèle de Rosenzweig - MacArthur\", \n                va='top', fontsize='14')\n\n## calcul des isoclines nulles\nxplot = np.arange(0, K+.1, .1)  \nyplot = np.arange(0, K+.1, .1)\n\nnull_x_x = np.zeros_like(yplot)        \nnull_x_y = r/c*(h+xplot)*(1-xplot/K)   \n\nnull_y_y = np.zeros_like(xplot)        \nnull_y_x = np.ones_like(yplot)*m*h/(b-m)\n\n## équilibres\neq_extinct = [0, 0]\neq_coex = [m*h/(b-m), r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K)]\neq_prey = [K, 0]\n\n## tracé des isoclines nulles, des équilibres, et de la trajectoire simulée\nax2.plot(null_x_x, yplot, color = 'C2')\nax2.plot(xplot, null_x_y, color = 'C2', label = \"isoclines nulles de $\\dot x$\")\nax2.plot(xplot, null_y_y, color = 'C1')\nax2.plot(null_y_x, yplot, color = 'C1', label = \"isoclines nulles de $\\dot y$\")\n\n## équilibres\nax2.plot(eq_extinct[0], eq_extinct[1], marker ='.', color = 'C3', markersize = 16)\nax2.plot(eq_coex[0], eq_coex[1], marker ='.', color = 'C3', markersize = 16)\nax2.plot(eq_prey[0], eq_prey[1], marker ='.', color = 'C3', markersize = 16)\n\n## trajectoires\nax2.plot(int_RMA[:, 0], int_RMA[:, 1], color = 'C0', label = \"trajectoire\")\n\n## enluminures\nax2.set_xlabel('Proies $x$', fontsize='12')\nax2.set_ylabel('Prédateurs $y$', fontsize='12')\nax2.legend(fontsize='10', loc = \"upper right\")\nax2.set_ylim(bottom=-.2, top=None)\nax2.set_xlim(left=-.2, right=None)\n\n## représentation du champs de vecteurs\nx_grid = np.linspace(0.1, K, 10)   \ny_grid = np.linspace(0.1, K, 10)\nX, Y = np.meshgrid(x_grid, y_grid)\n\n## dérivées dot_x et dot_y sur la grille\ndx, dy = model_RMA([X, Y], 0, params_RMA)\n\nax2.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', width = .002);\n\n\n\n\n\nFigure 7: plan de phase du modèle de Rosenzweig et MacArthur (Equation 2)\n\n\n\n\n\n\nDiagramme de bifurcations\nNous allons représenter les asymptotiques de la population de prédateurs y^* en fonction de K. Il y a 3 situations asymptotiques distinctes pour le modèle de Rosenzweig MacArthur :\n\nsi : 0<K<\\displaystyle\\frac{mh}{b-m} : les prédateurs s’éteignent et les proies convergent vers K, l’équilibre d’extinction des deux populations est instable.\nsi : \\displaystyle\\frac{mh}{b-m} <K< h+\\frac{2mh}{b-m} : proies et prédateurs co-existent à un équilibre globalement asymptotiquement stable, l’équilibre d’extinction des prédateurs est instable, l’équilibre d’extinction des deux populations est instable.\nsi : h+\\displaystyle\\frac{2mh}{b-m}<K proies et prédateurs co-existent le long d’un cycle limite globalement asymptotiquement stable, l’équilibre d’extinction des prédateurs est instable, l’équilibre d’extinction des deux populations est instable.\n\nDans un premier temps nous allons calculer et représenter les différents équilibres et leur stabilité dans le plan (K, y), puis nous calculerons et rajouterons une représentation du cycle limite.\nCommençons par les équilibres :\n\n\nCode\npas_K = .1\n\n## situation 1. \nKplot1 = np.arange(pas_K, m*h/(b-m)+pas_K, pas_K) \ny_prey1 = np.zeros_like(Kplot1)                    \n\n## situation 2.\nKplot2 = np.arange(m*h/(b-m), h+2*m*h/(b-m)+pas_K, pas_K)\ny_prey2 = np.zeros_like(Kplot2)                    \ny_coex2 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K_p) for K_p in Kplot2]\n\n## situation 3.\nKplot3 = np.arange(h+2*m*h/(b-m), 8, pas_K/2)      \ny_prey3 = np.zeros_like(Kplot3)                    \ny_coex3 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K_p) for K_p in Kplot3]\n\n\nReprésentation graphique :\n\n\nCode\nfig3, ax3 = plt.subplots(1, 1)  \nfig3.suptitle(\"Diagramme de bifurcations $y^*$ en fonction de $K$\",\n             va='top', fontsize='14')\n\n## tracé des différentes branches d'équilibres\n## situation 1.\nax3.plot(Kplot1, y_prey1, color = 'C2', label = \"équilibre stable\")\n\n## situation 2.\nax3.plot(Kplot2, y_prey2, color = 'C1', label = \"équilibre instable\")\nax3.plot(Kplot2, y_coex2, color = 'C2')\n\n## situation 3.\nax3.plot(Kplot3, y_prey3, color = 'C1')\nax3.plot(Kplot3, y_coex3, color = 'C1')\n\n## enluminures\nax3.set_ylabel('densité de prédateurs $y_\\infty$', fontsize='12')\nax3.set_xlabel('capacité de charge $K$', fontsize='12')\n\n## Type des bifurcations\nax3.text(2.2, 0.1, 'transcritique', fontsize='12')\nax3.text(5.15, 2.75, 'Hopf', fontsize='12')\n\nax3.grid()\n\n\n\n\n\nFigure 8: diagramme de bifurcation y^* en fonction de K pour le modèle de Rosenzweig MacArthur (Equation 2)\n\n\n\n\nOn aimerait pouvoir visualiser sur le diagramme de bifurcations l’amplitude du cycle limite attractif qui émerge de l’équilibre instable. Pour cela, on utilise une approche qui consiste à simuler pendant longtemps le système dynamique et récupérer les extrema de la trajectoire périodique pour ensuite les tracer (approche “brute force”).\n\n## temps d'intégration du transitoire \"long\"\ntspan_transitoire = np.arange(t_0, 100*t_fin, pas_t)\n\n## array pour sauvegarder les extrema de la trajectoire périodique\ny_cycle_min = np.array([])\ny_cycle_max = np.array([])\n\nfor K_p in Kplot3:\n    ## on assigne le paramètre K à la valeur K_p\n    params_RMA_cycle = np.array([r, K_p, c, h, b, m])\n    \n    ## on simule le système pendant le transitoire\n    int_RMA_transitoire =  odeint(model_RMA, \n            etat0_RMA, tspan_transitoire, args=(params_RMA_cycle,), \n            hmax=pas_t)\n    \n    ## on resimule depuis la dernière valeur calculée \n    ## dans la simulation du transitoire\n    int_RMA_cycle = odeint(model_RMA, int_RMA_transitoire[-1, :], \n            tspan, args=(params_RMA_cycle,), hmax=pas_t)\n    \n    ## on sauvegarde les extremas dans y_cycle_min et \n    ## _max en appendant les array et les réassignant\n    y_cycle_min = np.append(y_cycle_min, np.min(int_RMA_cycle[:,1]))\n    y_cycle_max = np.append(y_cycle_max, np.max(int_RMA_cycle[:,1]))\n\nIl ne reste plus qu’à tracer ces branches correspondant au cycle limite.\n\nax3.plot(Kplot3, y_cycle_min, color = 'C0', label = \"cycle limite attractif\")\nax3.plot(Kplot3, y_cycle_max, color = 'C0')\n\n## légende\nax3.legend(fontsize='10')\n\n## réafficher la figure\ndisplay(fig3)\n\n\n\n\nFigure 9: diagramme de bifurcation y^* en fonction de K pour le modèle de Rosenzweig MacArthur (Equation 2)\n\n\n\n\nThat’s all folks!"
  },
  {
    "objectID": "pop_isolees.html",
    "href": "pop_isolees.html",
    "title": "Populations isolées",
    "section": "",
    "text": "Nous considérons le modèle proposé par Malthus (1798) : \n\\dot x = (n-m)x,\n\\tag{1} avec n le taux de natalité, et m le taux de mortalité.\nPour simuler ce modèle, c’est à dire intégrer numériquement les solutions au problème de Cauchy correspondant à l’Equation 1 et x(0)=x_0\\geq0, nous allons utiliser les modules numpy et matplotlib.pyplot, et la méthode odeint de scipy.integrate.\n\n\nOn commence par nettoyer l’espace de travail, dans Jupyter :\n\n%reset -f\n\nEt on importe les modules cités précédemment :\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom scipy.integrate import odeint\n\n\n\n\nDéfinissons le modèle: une fonction de l’état x, du temps t (nécessaire pour odeint), de paramètres, qui renvoit la dérivée \\dot x.\n\ndef model_malthus(etat, t, params): \n    x = etat        # unpack l'etat\n    n, m = params   # unpack params -> params locaux \n    xdot = (n-m)*x  # calcule la derivee de l'etat \n    return xdot     # renvoit la derivée \n\n\n\n\n\n\n\nImportant\n\n\n\nOn fera attention a bien désencapsuler les états/paramètres/etc. dans le même ordre que l’encapsulation faite dans le corps du programme (cf. ci-dessous).\n\n\n\n\n\nDéfinissons les conditions initiales, et encapsulons le dans un np.array :\n\nx0 = 0.1\n\netat0_malthus = np.array([x0])\n\nDéfinissons les paramètres et encapsulons les :\n\nn = 3.0     # taux de natalité\nm = 2.0     # taux de mortalité\n\nparams_malthus = np.array([n, m])\n\nDéfinissons le temps d’intégration tspan (vecteur entre le temps initial et le temps final):\n\nt_0 = 0.0           # temps initial\nt_fin = 10.0        # temps final\npas_t = 0.01        # pas de temps \n\ntspan = np.arange(start=t_0, stop=t_fin, step=pas_t)\n\n\n\n\nIl s’agit d’utiliser la fonction odeint de scipy :\n\nint_malthus = odeint(\n                model_malthus,         # système dynamique\n                etat0_malthus,          # condition initiale\n                tspan,                  # temps d'intégration\n                args=(params_malthus,), # paramètres du syst. dyn. ici un tuple \n                                        ## à un élément (cf. virgule)\n                hmax=pas_t)             # pas d'intégration max. sur temps\n\n\n\n\n\n\n\nImportant\n\n\n\nL’appel à odeint est très précis et doit respecter les règles et l’ordre indiqués ci-dessus.\n\n\nL’intégration est faite :\n\nint_malthus[:5]\n\narray([[0.1       ],\n       [0.10100502],\n       [0.10202014],\n       [0.10304547],\n       [0.10408109]])\n\n\nIl reste à représenter graphiquement la solution calculée.\n\n\n\nCréons une figure et deux systèmes d’axes pour représenter deux sous-figures, puis traçons l’évolution de x(t) calculée numériquement en fonction du temps (gauche) ou la solution mathématique x(t)=e^{(n-m)t} x_0 (droite). La représentation est visible dans la Figure 1.\nDécouvrons aussi différentes options des méthodes subplots(), plot(), legend(), l’utilisation de LaTeX dans les chaînes de caractères, ou les fstrings de Python 3 pour compléter les chaines de caractères avec des valeurs via \"\".format().\n\n## figure et systèmes d'axes\nfig1, (ax1, ax2) = plt.subplots(1, 2)  \n\n## titre de la figure\nfig1.suptitle('Simulation du modèle de Malthus\\n $n = {}, m = {}$'.format(n, m), \n              va='top', fontsize='14')\n\n## premier subplot\nax1.plot(tspan, int_malthus, \n         color='C0', \n         label='$x(t)$ (numérique)')\n\n## modification des bornes\nax1.set_ylim(bottom=None, top=None)\n\n## axes / légendes / grille\nax1.legend(fontsize='10')\nax1.set_xlabel('Temps $t$', fontsize='12')\nax1.set_ylabel('Densité de population $x$', fontsize='12')\nax1.grid()\n\n\n## second subplot\nax2.plot(tspan, np.exp((n-m)*tspan)*x0, \n         color='C2', \n         label='$x(t)$ (analytique)')\n\n## axes / légendes / grille\nax2.legend(fontsize='10')\nax2.set_xlabel('Temps $t$', fontsize='12')\nax2.grid()\n\n\n\n\nFigure 1: simulation et solution mathématique du modèle de Malthus (Equation 1)\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nMalgré une bonne précision d’intégration, une simulation/intégration numérique reste une approximation des solutions mathématiques, et par construction induit donc des erreurs, comme l’illustre la Figure 2.\n\n\n\n\nCode\nfig2, ax3 = plt.subplots(1, 1)\nax3.plot(tspan, \n         int_malthus[:,0]-np.exp((n-m)*tspan)*x0, \n         color='C1', \n         label='$x(t)$ (numérique)')\n\nfig2.suptitle('Erreur d\\'intégration pour le modèle de Malthus', \n            va='top', fontsize='14')\nax3.set_xlabel('Temps $t$', fontsize='12')\nax3.set_ylabel('Erreur d\\'intégration', fontsize='12')\nax3.grid()\n\n\n\n\n\nFigure 2: Erreur à l’intégration numérique du modèle de Malthus (Equation 1)"
  },
  {
    "objectID": "pop_isolees.html#sec-logistic",
    "href": "pop_isolees.html#sec-logistic",
    "title": "Populations isolées",
    "section": "Le modèle logistique",
    "text": "Le modèle logistique\nNous considérons ici le modèle “logistique” proposé par Verhulst (1938) :\n\n\\dot x = r x \\left(1-\\frac{x}{K}\\right),\n\\tag{2} avec r le taux de croissance intrinsèque de la population et K la capacité de charge de l’environnement.\nIl n’y a pas de difficulté particulière par rapport aux simulations précedentes. On commence par nettoyer l’espace de travail, puis ré-importer les modules nécessaires :\n\n%reset -f\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\nLa définition du modèle, des conditions initiales et paramètres, l’intégration et la représentation graphique suivent les étapes vues précédemment.\n\nSimulation\n\nDéfinition du système dynamique :\n\n\n\nCode\ndef model_logistic(etat, t, params): \n    x = etat        \n    r, K = params   \n    xdot = r*x*(1-x/K)  \n    return xdot     \n\n\n\nCondition initiale, paramètres, tspan :\n\n\n\nCode\n## condition initiale\nx0 = 0.1\netat0_logistic = np.array([x0])\n\n## paramètres\nr = 1.0     # taux de croissance intrinsèque\nK = 10.0    # capacité de charge\nparams_logistic = np.array([r, K])\n\n## tspan\nt_0 = 0.0           \nt_fin = 10.0        \npas_t = 0.01        \ntspan = np.arange(t_0, t_fin, pas_t)\n\n\n\nIntégration :\n\n\n\nCode\nint_logistic = odeint(\n                model_logistic,        \n                etat0_logistic,         \n                tspan,                  \n                args=(params_logistic,),\n                hmax=pas_t)             \n\n\n\n\nReprésentation graphique\n\n\nCode\n## figure et systèmes d'axes\nfig, ax = plt.subplots(1, 1)  \n\n## titre de la figure\nfig.suptitle('Simulation du modèle logistique ; $r = {}, K = {}$'.format(r, K), \n              va='top', fontsize='14')\n\n## simulation\nax.plot(tspan, int_logistic, \n         color='C0', \n         label='$x(t)$') # solution\n\n## équilibres\nax.plot(tspan, np.zeros_like(tspan),\n        color = 'C3',\n        linestyle = 'dashed',\n        label = \"équilibre instable\")\nax.plot(tspan, np.ones_like(tspan)*K,\n        color = 'C2',\n        linestyle = 'dashed',\n        label = \"équilibre stable\")\n\n## modification des bornes\nax.set_ylim(bottom=None, top=None)\n\n## axes / légendes / grille\nax.legend(fontsize='10')\nax.set_xlabel('Temps $t$', fontsize='12')\nax.set_ylabel('Densité de population $x$', fontsize='12')\nax.grid()\n\n\n\n\n\nFigure 3: simulation du modèle logistique (Equation 2)"
  },
  {
    "objectID": "pop_isolees.html#sec-allee",
    "href": "pop_isolees.html#sec-allee",
    "title": "Populations isolées",
    "section": "Effets Allee",
    "text": "Effets Allee\nOn s’intéresse à un modèle de dynamique de population avec “effets Allee forts”, souvent attribué à Gruntfest, Arditi, and Dombrovsky (1997)1 :1 mais de nombreuses variations de cette forme polynomiale existent dans la littérature depuis Bazykin (1985)\n\n\\dot x = r x \\left(\\frac{x}{\\epsilon}-1\\right)\\left(1-\\frac{x}{K}\\right),\n\\tag{3} avec r le taux de croissance intrinsèque de la population (par analogie avec la logistique), K la capcité de charge de l’environnement et \\epsilon le seuil en dessous duquel la population n’est pas viable (‘seuil de Allee’). On procède comme ci-dessus.\n\nSimulation : préliminaires\n\nnettoyage de l’espace de travail et chargement des modules :\n\n\n\nCode\n%reset -f\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\n\n\nDéfinition du système dynamique :\n\n\n\nCode\ndef model_allee(etat, t, params): \n    x = etat        \n    r, K, epsilon = params   \n    xdot = r*x*(x/epsilon-1)*(1-x/K)  \n    return xdot     \n\n\n\nParamètres, tspan :\n\n\n\nCode\n## paramètres\nr = 1.0       # taux de croissance intrinsèque\nepsilon = 2.0 # seuil de Allee\nK = 10.0      # capacité de charge\nparams_allee = np.array([r, K, epsilon])\n\n## tspan\nt_0 = 0.0           \nt_fin = 3.0        \npas_t = 0.01        \ntspan = np.arange(t_0, t_fin, pas_t)\n\n\n\n\nSimulation : conditions initiales multiples\nPour mettre en valeur la bi-stabilité du système dynamique défini par l’Equation 3, nous créons une fonction qui intègre le problème de Cauchy depuis une condition initiale donnée.\n\ndef int_allee(x0, tspan=tspan, params=params_allee):\n    sim_allee = odeint(\n                model_allee,        \n                x0,             # argument de la fonction \n                tspan,          # argument de la fonction \n                args=(params,), # argument de la fonction \n                hmax=pas_t)\n    return sim_allee\n\n\n\n\n\n\n\nNote\n\n\n\nNous remarquons l’utilisation de kwargs (keyword arguments tspan et params), des arguments qui prendront leur valeur par défaut si ils ne sont pas re-spécifiés dans l’appel de la fonction int_allee().\n\n\nVérifions que la fonction réalise bien ce qui est attendu :\n\nint_allee(0.1)[:5,0]\n\narray([0.1       , 0.09906363, 0.09813549, 0.09721551, 0.09630365])\n\n\n\n\nReprésentation graphique\nL’idée est de représenter plusieurs trajectoires issues de plusieurs conditions initiales. Créons un array de conditions initiales :\n\nx0_step = 1.35\nx0_arr = np.arange(x0_step, K, x0_step)\n\nPuis nous faisons la représentation graphique via une boucle exploitant la fonction int_allee() :\n\nfig, ax = plt.subplots(1, 1)  \nfig.suptitle('Simulation du modèle avec effets Allee'\\\n    '; $r={}, K={}, \\epsilon={}$'.format(r, K, epsilon), \n              va='top', fontsize='14')\n\n## redéfinition du cycle des couleurs pour un dégradé de bleu\ncolorAllee = plt.cm.Blues(np.linspace(.8, .3, x0_arr.shape[0]))\nax.set_prop_cycle(color = colorAllee)\n\n## simulations\nax.plot(tspan, int_allee(x0_arr[0]),\n        label = \"$x(t)$\")\nfor x0 in x0_arr[1:]:       # x0 parcour x0_arr\n    ax.plot(tspan, int_allee(x0)) \n\n## équilibres\nax.plot(tspan, np.zeros_like(tspan),\n        color = 'C2',\n        linestyle = 'dashed',\n        label = \"équilibre stable\")\nax.plot(tspan, np.ones_like(tspan)*K,\n        color = 'C2',\n        linestyle = 'dashed')\nax.plot(tspan, np.ones_like(tspan)*epsilon,\n        color = 'C3',\n        linestyle = 'dashed',\n        label = \"équilibre instable\")\n\n## axes / légendes / grille\nax.legend(fontsize='10')\nax.set_xlabel('Temps $t$', fontsize='12')\nax.set_ylabel('Densité de population $x$', fontsize='12')\nax.grid()\n\n\n\n\nFigure 4: simulation du modèle avec effets Allee forts (Equation 3)\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNous utilisons une boucle avec x0 parcourant les conditions initiales x0_arr pour tracer les différentes solutions.\n\n\n\n\n\n\n\n\nNote\n\n\n\nLe dégradé de bleu des simulations est obtenu en créant une colormap à partir de plt.cm.Blues() ayant pour argument un array à valeurs dans [0,1], de la même taille que le nombre de courbes à tracer. Cette colormap redéfini ensuite le cycle de couleurs du système d’axes via ax.set_prop_cycle(color = foo).\n\n\nLa suite sur les populations exploitées par-ici."
  },
  {
    "objectID": "pop_exploitees.html",
    "href": "pop_exploitees.html",
    "title": "Populations exploitées",
    "section": "",
    "text": "Nous reprenons le modèle précédent sur l’effet Allee mais en prenant en compte des prélèvements externes avec un effort (taux) de prélèvement E : \n\\dot x = r x \\left(\\frac{x}{\\epsilon}-1\\right)\\left(1-\\frac{x}{K}\\right)-Ex.\n\\tag{1}\nLa simulation de ce modèle pour différentes valeurs de E (par exemple E=0.2 ou E=0.85) ne présente aucune difficulté supplémentaire.\nNous allons maintenant nous intéresser à une situation où l’effort de prélèvement E varie au cours du temps entre une valeur soutenable E_s (par exemple 0.2), et une valeur excessive E_x (par exemple 0.85).\nL’attendu théorique est que si les prélèvements sont maintenus à une valeur excessive E_x trop longtemps, la population disparait irrémédiablement même si les prélèvements sont ramenés à une valeur initialement soutenable E_s.\n\n\n\nnettoyage de l’espace de travail et chargement des modules\n\n\n\nCode\n%reset -f\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\n\nDéfinissons la fonction Evar(), qui renvoit E_s si t est plus petit que T_s ou plus grand que T_s+T_x, et E_x sinon.\nDéfinissons d’abord les paramètres de la fonction et encapsulons les :\n\nE_s = 0.2\nE_x = 0.85\nT_s = 10.0\nT_x = 9.0\n\nparams_Evar = np.array([E_s, E_x, T_s, T_x])\n\nDéfinissons la fonction Evar() :\n\ndef Evar(t, params):\n    E_s, E_x, T_s, T_x = params\n    if t <= T_s or t > T_s+T_x:\n        return E_s\n    else:\n        return E_x\n\nDéfinissons les autres paramètres du modèle et l’intervalle de temps considéré\n\n\nCode\n## paramètres\nr = 1.0       # taux de croissance intrinsèque\nepsilon = 2.0 # seuil de Allee\nK = 10.0      # capacité de charge\nparams_allee = np.array([r, K, epsilon])\n\n## tspan\nt_0 = 0.0           \nt_fin = 30.0        \npas_t = 0.01        \ntspan = np.arange(t_0, t_fin, pas_t)\n\n\nLa fonction se comporte bien comme attendu (Figure 1).\n\n\nCode\nfig, ax = plt.subplots(1, 1, figsize=(6,4))  \nfig.suptitle('Evar() en fonction du temps',\n              va='top', fontsize='14')\n\nax.plot(tspan, [Evar(t, params_Evar) for t in tspan], label = \"Evar(t)\")\n\n## axes / légendes / grille\nax.legend(fontsize='10')\nax.set_xlabel('Temps $t$', fontsize='12')\nax.set_ylabel('Effort de prélèvement', fontsize='12')\nax.grid()\n\n\n\n\n\nFigure 1: représentation de la fonction Evar() en fonction du temps\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nOn notera l’ultilisation d’une compréhension de liste pour le tracé de Evar(). En effet, la fonction avec son test if travaille sur un argument t qui est un scalaire et renvoit un scalaire ce qui ne permet pas d’appeler Evar(tspan) directement.\n\n\n\n\n\nDéfinissons le système dynamique comme usuellement :\n\ndef model_alleePrelev(etat, t, params, paramsEv): \n    x = etat              # on recupere l'etat\n    r, K, epsilon = params     # on récupère les paramètres\n    xdot = r*x*(x/epsilon-1)*(1-x/K) - Evar(t, paramsEv)*x    # la derivee \n    return xdot    \n\n\n\n\n\n\n\nImportant\n\n\n\nA la différente de précédemment, le modèle est ici non-autonome (la dérivée dépend du temps en plus de l’état) via la fonction Evar(t).\n\n\nIntégrons :\n\n## condition initiale\nx0 = K\n\n## intégration\nint_alleePrelev = odeint(model_alleePrelev,\n                         x0,\n                         tspan,\n                         args=(params_allee, params_Evar),\n                         hmax=pas_t)\n\n\n\n\n\n\n\nNote\n\n\n\nComme la fonction Evar() a deux arguments de paramètres, on les passe passe à la suite comme tuple à args.\n\n\nReprésentation graphique, lorsque la durée des prélèvements excessifs n’est pas trop longue la population récupère de la pression de prélèvement trop intense :\n\n\nCode\nfig1, ax1 = plt.subplots(1, 1)  \nfig1.suptitle('Simulation du modèle avec effets Allee'\\\n    ' forts et prélèvements; $T_x={}$'.format(T_x), \n              va='top', fontsize='14')\n\n## simulation\nax1.plot(tspan, int_alleePrelev,\n        label = \"$x(t)$\")\n\n## axes / légendes / grille\nax1.legend(fontsize='10')\nax1.set_xlabel('Temps $t$', fontsize='12')\nax1.set_ylabel('Densité de population $x$', fontsize='12')\nax1.grid()\n\n\n\n\n\nFigure 2: simulation du modèle avec effets Allee forts et prélèvements (Equation 1)\n\n\n\n\nPar contre, si la durée des prélèvements est trop longue, la population est conduite à l’extinction.\nModification du paramètre T_x, réintégration, représentation :\n\n\nCode\n## redefinition de T_x et des paramètres\nT_x2 = 9.2\nparams_Evar2 = np.array([E_s, E_x, T_s, T_x2])\n\n## intégration\nint_alleePrelev2 = odeint(model_alleePrelev,\n                         x0,\n                         tspan,\n                         args=(params_allee, params_Evar2),\n                         hmax=pas_t)\n\nfig2, ax2 = plt.subplots(1, 1)  \nfig2.suptitle('Simulation du modèle avec effets Allee forts '\\\n    'et prélèvements; $T_x={}$'.format(T_x), \n              va='top', fontsize='14')\n\n## simulation\nax2.plot(tspan, int_alleePrelev2,\n        label = \"$x(t)$\")\n\n## axes / légendes / grille\nax2.legend(fontsize='10')\nax2.set_xlabel('Temps $t$', fontsize='12')\nax2.set_ylabel('Densité de population $x$', fontsize='12')\nax2.grid()\n\n\n\n\n\nFigure 3: simulation du modèle avec effets Allee forts et prélèvements (Equation 1)\n\n\n\n\n\n\n\nUne représentation complémentaire dans l’expace (E,x^*), permet de bien saisir le phénomène de catastrophe lié à la présence d’une bifurcation pli.\nNous commençons par calculer le lieu des équilibres en fonction de E puis traçons les deux cas simulés plus haut pour deux valeurs de T_x.\nLes équilibres sont définis par :\n\nx^*=0 est toujours équilibre\nles équilibres x^* positifs vérifient : \nE = r\\left(\\frac{x^*}{K_a}-1\\right)\\left(1-\\frac{x^*}{K}\\right)\n\n\nTraçons tout d’abord les lieux des équilibres :\n\n\nCode\n## définition de vecteurs annexes E_plot et x_plot \nE_plot = np.arange(0, 1, 0.01)\nx_plot_l = np.arange(epsilon, (K+epsilon)/2, 0.01)\nx_plot_L = np.arange((K+epsilon)/2, K, 0.01)\n\n## définition des valeurs de E correspondant aux équilibres positifs\nE_eq_l = r*(x_plot_l/epsilon-1)*(1-x_plot_l/K)\nE_eq_L = r*(x_plot_L/epsilon-1)*(1-x_plot_L/K)\n\n## création d'une figure, et de deux subplots (ax6, ax7)\nfig2, (ax3, ax4) = plt.subplots(1, 2, figsize=(9, 6))  \n\n## titre de la figure\nfig2.suptitle('Effet Allee forts et prèlevements\\n '\\\n    '$T_x$ = {} (gauche), $T_x$ = {} (droite)'\n              .format(T_x, T_x2), va='top', fontsize='14')\n\n## premier subplot\n## tracé du lieu des équilibres\nax3.plot(E_plot, np.zeros_like(E_plot), color = 'C2')\nax3.plot(E_eq_L, x_plot_L, color='C2', label='équilibre stable')\nax3.plot(E_eq_l, x_plot_l, color='C3', label='équilibre instable')\n\n## labellisation des axes\nax3.set_xlabel('effort de prélèvement $E$', fontsize='12')\nax3.set_ylabel('densité de population $x$', fontsize='12')\nax3.grid()\n\n## second subplot\n## tracé du lieu des équilibres\nax4.plot(E_plot, np.zeros_like(E_plot), color = 'C2')\nax4.plot(E_eq_L, x_plot_L, color='C2', label='équilibre stable')\nax4.plot(E_eq_l, x_plot_l, color='C3', label='équilibre instable')\n\n## labellisation des axes\nax4.set_xlabel('effort de prélèvement $E$', fontsize='12')\nax4.grid()\n\nplt.close(fig2)\n\n\nOn complète la figure avec l’ajout des trajectoires en fonction de E et affichage de la figure complète :\n\n## premier subplot\nax3.plot([Evar(t, params_Evar) for t in tspan], int_alleePrelev, \n         color = 'C0', label = 'trajectoire')\nax3.legend(fontsize='10', loc = 'lower right', \n           bbox_to_anchor=(0.5, 0.05, 0.5, 0.5))\n\n## second subplot\nax4.plot([Evar(t, params_Evar2) for t in tspan], int_alleePrelev2, \n         color = 'C0', label = 'trajectoire')\nax4.legend(fontsize='10', loc = 'lower right', \n           bbox_to_anchor=(0.5, 0.05, 0.5, 0.5))\n\ndisplay(fig2)\n\n\n\n\nFigure 4: bifurcation pli et catastrophe dans le modèle avec effet Allee et prélèvements\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNotons le remplissage de la figure en deux cellules Jupyter successives, avec un seul affichage grace à plt.close() et display()."
  },
  {
    "objectID": "pop_exploitees.html#sec-tordeuse",
    "href": "pop_exploitees.html#sec-tordeuse",
    "title": "Populations exploitées",
    "section": "La tordeuse du bourgeon de l’épinette",
    "text": "La tordeuse du bourgeon de l’épinette\n\nPopulation d’oiseaux constante\nNous considérons le modèle de dynamique de populations suivant, inspiré de Ludwig, Jones, and Holling (1978) :\n\n\\dot x =rx\\left(1-\\frac{x}{K}\\right) - \\frac{\\alpha x^2}{h^2+x^2}\\ y\n\\tag{2}\nOn procède classiquement :\n\n\nCode\n## on nettoie l'espace de travail et on reload les modules\n%reset -f\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\n## tspan\nt_0 = 0             \nt_fin = 3.0        \npas_t = 0.01\ntspan = np.arange(t_0, t_fin, pas_t)\n\n## paramètres du modèle\nr = 5.0\nK = 10.0\nalpha = 1.0\nh = 0.5\ny_c = 7.0\nparams_tordeuse_yc = np.array([r, K, alpha, h, y_c])\n\n## définition du modèle tordeuse avec pop oiseaux constante\ndef model_tordeuse_yc(etat, t, params): \n    x = etat              # on recupere l'etat\n    r, K, alpha, h, y_c = params     # on récupère les paramètres\n    xdot = r*x*(1-x/K) - alpha*(x**2)*y_c/((h**2)+(x**2))    # la derivee \n    return xdot           # on renvoie la derivée calculée\n\n\nPour mettre en valeur la multi-stabilité, nous intégrons depuis plusieurs conditions initiales, comme dans la section sur l’effet Allee, et définissons une fonction pour faire une boucle :\n\n\nCode\ndef int_tordeuse(x0, tspan=tspan, params=params_tordeuse_yc):\n    sim_tordeuse = odeint(\n                model_tordeuse_yc,        \n                x0,              \n                tspan,           \n                args=(params,),  \n                hmax=pas_t)\n    return sim_tordeuse\n\n## multi-conditions initiales\nx0_step = 1.35\nx0_arr = np.arange(x0_step, K, x0_step)\n\n\nLa représentation graphique suit le modèle de la section que nous complèterons ensuite avec les équilibres positifs.\n\n\nCode\nfig, ax = plt.subplots(1, 1)  \nfig.suptitle('Simulation du modèle de tordeuse avec population'\\\n    ' d\\'oiseaux constante', \n              va='top', fontsize='14')\n\n## redéfinition du cycle des couleurs pour un dégradé de bleu\ncolorTordeuse = plt.cm.Blues(np.linspace(.8, .3, x0_arr.shape[0]))\nax.set_prop_cycle(color = colorTordeuse)\n\n## simulations\nax.plot(tspan, int_tordeuse(x0_arr[0]),\n        label = \"$x(t)$\")\nfor x0 in x0_arr[1:]:       # x0 parcour x0_arr\n    ax.plot(tspan, int_tordeuse(x0)) \n\n## équilibres\nax.plot(tspan, np.zeros_like(tspan),\n        color = 'C3',\n        linestyle = 'dashed',\n        label = \"équilibre instable\")\n\n## axes / légendes / grille\nax.set_xlabel('Temps $t$', fontsize='12')\nax.set_ylabel('Densité de population $x$', fontsize='12')\nax.grid()\nplt.close(fig)\n\n\nLes équilibres positifs sont solutions d’un polynôme de degré 3 : \nr\\left(1-\\frac{x^*}{K}\\right)\\left(h^2+x^{*2}\\right)-\\alpha x^* y = 0,\n\\tag{3} et ils n’ont pas de forme facile à expliciter analytiquement. Nous allons les calculer numériquement via les méthodes pour polynômes de numpy pour pouvoir les intégrer à la figure précédente.\n\n## monôme de degré 1\nz = np.polynomial.Polynomial([0, 1])\n\n## polynome dont les racines sont les x* > 0\npol = r*(1-z/K)*(h**2+z**2)-alpha*z*y_c\n\n## on calcule les racines et on récupère seulement les réelles, > 0 et < K\neq_pos = pol.roots()[(np.isreal(pol.roots())) \n            * (pol.roots() < K) * (pol.roots() > 0)] \n\n\n\n\n\n\n\nNote\n\n\n\npol.roots() renvoit un array avec toutes les racines de l’Equation 3. Les seules qui font sens dans notre problème sont les racines réelles, positives, et plus petites que K. Nous utilisons un masque booléen sur l’array renvoyé pour filtrer seulement les racines vérifiant ces conditions.\n\n\nComplétons maintenant la figure :\n\n## d'après l'étude mathématique, on s'attend à 1 ou 3 équilibres positifs\nif eq_pos.size == 1:\n    ax.plot(tspan, np.ones_like(tspan)*eq_pos, \n            color='C2', label =\"équilibre stable\")\n\nelif eq_pos.size == 3:\n    ax.plot(tspan, np.ones_like(tspan)*eq_pos[0], \n            linestyle = 'dashed', color='C2', label='équilibre stable')\n    ax.plot(tspan, np.ones_like(tspan)*eq_pos[1], \n            linestyle = 'dashed', color='C3')\n    ax.plot(tspan, np.ones_like(tspan)*eq_pos[2], \n            linestyle = 'dashed', color='C2')\n\nax.legend(fontsize='10')\ndisplay(fig)\n\n\n\n\nFigure 5: simulation du modèle de tordeuse, population d’oiseaux constante (Equation 2)\n\n\n\n\nPour le diagramme de bifurcation dans l’espace (y, x), on commence par calculer les différentes branches du lieu des points d’équilibre positifs\n\n## équilibres positifs\n## on récupère les extrema du lieu des équilibres positifs \nfrom sympy import Symbol, solve, Derivative, re\nx = Symbol('x')\n## lieu des équilibres\nyfunc = r*(1-x/K)*(h**2+x**2)/(alpha*x)\n## dérivée\ndyfunc = Derivative(yfunc, x).doit()\n## points critiques positifs. \n## solve() renvoit ici des complexes avec partie Im. presque nulles\ncrit_points = [re(root) for root in solve(dyfunc) if re(root)>0]\n\n## on calcule chacune des branches\nxplot1 = np.arange(0.01, crit_points[0], 0.01)\nxplot2 = np.arange(crit_points[0], crit_points[1], 0.01)\nxplot3 = np.arange(crit_points[1], K, 0.01)\nyeq1 = r*(1-xplot1/K) / (alpha*xplot1)*(h**2+xplot1**2)\nyeq2 = r*(1-xplot2/K) / (alpha*xplot2)*(h**2+xplot2**2)\nyeq3 = r*(1-xplot3/K) / (alpha*xplot3)*(h**2+xplot3**2)\n\n\n\n\n\n\n\nNote\n\n\n\nNous avons utilisé ici le module sympy pour calculer les points critiques du lieu des points d’équilibre positifs. Notons la compréhension de liste pour générer les points critiques.\n\n\n\n\nCode\nfig2, ax2 = plt.subplots(1, 1)\n\nfig2.suptitle('Diagramme de bifurcation pour le modèle'\\\n    ' de tordeuse', \n              va='top', fontsize='14')\n\n## équilibre nul\nyplot = np.arange(0, 15, 0.1)\nax2.plot(yplot, np.zeros_like(yplot), color = \"C3\", label = \"équilibre instable\")\n\n## équilibres positifs\nax2.plot(yeq1, xplot1, color='C2', label='équilibre stable')\nax2.plot(yeq2, xplot2, color='C3')\nax2.plot(yeq3, xplot3, color='C2')\n\n## bornes abscisses\nax2.set_xlim(left = -.50, right = 15)\n\nax2.set_ylabel('Population de tordeuses $x$', fontsize='12')\nax2.set_xlabel('Population d\\'oiseaux $y$', fontsize='12')\nax2.legend(loc='center left')\nax2.grid()\n\n\n\n\n\nFigure 6: diagramme de bifurcation pour l’Equation 2 en fonction de la taille de population d’oiseaux\n\n\n\n\n\n\nPopulation d’oiseaux variable\nLe changement principal ici est la dimension du modèle (dimension 2) : les tailles de populations de tordeuses x et d’oiseaux y varient toutes deux au cours du temps en s’influençant l’une l’autre, avec une population d’oiseaux qui varie lentement (d’où le paramètre \\varepsilon).\nLe modèle prend la forme :\n\n\\left\\{\n\\begin{array}{l}\n\\displaystyle \\dot x = rx\\left(1-\\frac{x}{K}\\right) - \\frac{\\alpha x^2}{h^2+x^2}\\ y \\\\[.3cm]\n\\displaystyle \\dot y = \\varepsilon \\left(\\frac{n \\alpha x^2}{h^2+x^2}\\ y -m y\\right)\n\\end{array}\n\\right.\n\\tag{4}\nLa fonction odeint() intègre parfaitement ce type de système, il faut juste écrire correctement le système d’équations différentielle à passer à la fonction.\n\ndef model_tordeuse_yvar(etat, t, params):\n    x, y = etat                                 # recupere les variables d'etat\n    r, K, alpha, h, epsilon, n, m = params      # recupere les parametres \n    etatdot = [r*x*(1 - x/K) - alpha*x**2/(h**2+x**2)*y,   # dot x\n               epsilon*(n*alpha*x**2/(h**2+x**2)-m)*y]     # dot y\n\n    return etatdot                                      # renvoit la derivee\n\nDéfinissons les conditions initiales et paramètres :\n\n## densités initiales de populations\nx0 = 1\ny0 = 2.5\netat0_tordeuse_yvar = np.array([x0, y0]) # encapsulation \n\n## tspan\ntfin_yvar = 400.0\ntspan_yvar = np.arange(0.0, tfin_yvar, pas_t)\n\n## paramètres spécifiques à la population d'oiseaux\nepsilon = 0.01\nn = 5.0\nm = 3.0\nparams_tordeuse_yvar = np.array([r, K, alpha, h, epsilon, n, m])\n\nIntégrons (l’appel à odeint() est similaire) :\n\nint_tordeuse_yvar = odeint(\n                        model_tordeuse_yvar, \n                        etat0_tordeuse_yvar, \n                        tspan_yvar, \n                        args=(params_tordeuse_yvar,),\n                        hmax=pas_t)\n\nL’intégration renvoit un array dont la première colonne est la simulation de la population x et la seconde celle de la population y.\n\nint_tordeuse_yvar[:5,]\n\narray([[1.        , 2.5       ],\n       [1.02540404, 2.50025497],\n       [1.05163666, 2.50051974],\n       [1.07872903, 2.50079407],\n       [1.10671295, 2.50107772]])\n\n\nReprésentation graphique contre le temps :\n\n\nCode\nfig3, ax3 = plt.subplots(1, 1)  \nfig3.suptitle('Simulation du modèle de tordeuse'\\\n    ' avec population d\\'oiseaux variable', \n              va='top', fontsize='14')\n\n## simulations\nax3.plot(tspan_yvar, int_tordeuse_yvar[:,0], \n        color = 'C0',\n        label = \"$x(t)$\")\n\n## axes / légendes / grille\nax3.set_xlabel('Temps $t$', fontsize='12')\nax3.set_ylabel('Densité de population $x(t)$', fontsize='12')\nax3.legend()\nax3.grid()\n\n\n\n\n\nFigure 7: Simulation du modèle de tordeuse avec population d’oiseaux variables Equation 4\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNotons l’appel à toutes les lignes de la première colonne de int_tordeuse_var pour récupérer la simulation de la population de tordeuses.\n\n\nDans l’espace (y, x), on voit bien l’enchainement des catastrophes et le phénomène de ‘bifurcations dynamiques’ :\n\n\nCode\nfig2.suptitle('Diagramme de bifurcation pour le modèle de tordeuse', \n              va='top', fontsize='14')\n\nax2.plot(int_tordeuse_yvar[:,1], int_tordeuse_yvar[:,0], label='simulation')\nax2.legend()\ndisplay(fig2)\n\n\n\n\n\nFigure 8: Bifurcations dynamiques dans le modèle de tordeuse avec population d’oiseaux variables Equation 4\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nOn a tracé ici le lieu de la simulation population de tordeuses en fonction de la population d’oiseaux, le temps étant implicite.\n\n\nLa suite sur les populations en interactions par ici."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Présentation",
    "section": "",
    "text": "Ce site propose une introduction à la simulation d’équations différentielles avec Python 3 / Jupyter, centrée sur la simulation de modèles classiques en dynamique des populations.\nLe document est structuré comme suit :\n\nLa section sur les populations isolées introduit les bases en dimension 1 (modèle de Malthus, modèle logistique et effets Allee)\nla section sur les populations exploitées introduit les diagrammes de bifurcations et la dimension 2 (prélèvements et effets Allee, interactions insectes-oiseaux)\nla section sur les populations en interaction approfondit la dimension 2, notamment via les représentations dans l’espace d’état, et traite des interactions entre populations sous l’angle des modèles proies-prédateurs (modèle de Lotka Volterra et modèle de Rosenzweig MacArthur)\n\nAllons-y !\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "A propos",
    "section": "",
    "text": "Ces pages ont été générées avec Quarto, Jupyter et Python (version 3.10.8).\nLes principaux modules utilisés sont NumPy, Matplotlib, SciPy et SymPy.\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  }
]